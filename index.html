<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Underground 3D: Syndicate</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #0f0; 
            background: rgba(0,0,0,0.9); padding: 20px; border-left: 5px solid #00aaff;
            pointer-events: none; z-index: 10; width: 280px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .hp-bar { width: 100%; height: 12px; background: #300; border: 1px solid #500; margin-top: 8px; border-radius: 2px; }
        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #f00, #ff5555); transition: 0.3s; }
        #status { font-size: 11px; color: #00ffff; margin-top: 10px; text-transform: uppercase; letter-spacing: 1px; }
        #controls { font-size: 10px; color: #888; margin-top: 15px; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 22px; font-weight: bold; color: #fff;">SYNDICATE</div>
        <div id="rep-display" style="color: #00aaff;">REP: 0</div>
        <div class="hp-bar"><div id="hp-fill"></div></div>
        <div id="clique-display" style="color: #fff; margin-top: 5px;">CLIQUE SIZE: 1</div>
        <div id="status">STREETS: SEARCHING...</div>
        <div id="controls">WASD: MOVE | SPACE: ATTACK | SHIFT: SPRINT</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Scene & Camera ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        scene.fog = new THREE.Fog(0x0a0a0f, 15, 70);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Optimized Lighting ---
        const amb = new THREE.AmbientLight(0xffffff, 0.5); // Clear visibility
        scene.add(amb);
        const hemi = new THREE.HemisphereLight(0x4444ff, 0x000000, 0.6);
        scene.add(hemi);
        const point = new THREE.PointLight(0x00aaff, 20, 50); // Player glow
        scene.add(point);

        // --- Game State ---
        let rep = 0, hp = 100, isInsideGym = false;
        const enemies = [], clique = [], buildings = [];
        const keys = {};

        // --- Environment ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Gym Interior/Exterior
        const gymWalls = new THREE.Mesh(new THREE.BoxGeometry(15, 7, 15), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        gymWalls.position.set(-25, 3.5, -15);
        const gymRoof = new THREE.Mesh(new THREE.BoxGeometry(15.2, 0.5, 15.2), new THREE.MeshStandardMaterial({ color: 0x444444 }));
        gymRoof.position.set(-25, 7, -15);
        const gymPad = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 6), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 }));
        gymPad.position.set(-25, 0.05, -7);
        scene.add(gymWalls, gymRoof, gymPad);
        buildings.push(gymWalls);

        // Downtown Skyscrapers
        for(let i = 0; i < 20; i++) {
            const h = 15 + Math.random() * 30;
            const b = new THREE.Mesh(new THREE.BoxGeometry(8, h, 8), new THREE.MeshStandardMaterial({ color: 0x050505 }));
            const angle = (i / 20) * Math.PI * 2;
            b.position.set(Math.cos(angle) * 45, h/2, Math.sin(angle) * 45);
            scene.add(b);
            buildings.push(b);
        }

        // --- Actors ---
        const player = new THREE.Group();
        const pBody = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x00aaff }));
        pBody.position.y = 1;
        player.add(pBody);
        scene.add(player);
        player.position.set(0, 0, 20);

        function createCliqueMember() {
            const m = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x55ccff }));
            m.position.set(player.position.x, 0.9, player.position.z);
            scene.add(m);
            clique.push(m);
            document.getElementById('clique-display').innerText = `CLIQUE SIZE: ${clique.length + 1}`;
        }

        function spawnEnemy() {
            const e = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2, 1.1), new THREE.MeshStandardMaterial({ color: 0xff3333 }));
            const angle = Math.random() * Math.PI * 2;
            e.position.set(Math.cos(angle) * 20, 1, Math.sin(angle) * 20);
            e.userData = { hp: 60 };
            scene.add(e);
            enemies.push(e);
        }
        for(let i=0; i<4; i++) spawnEnemy();

        // --- Input ---
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function update() {
            // Movement logic
            let speed = keys['shift'] ? 0.35 : 0.2;
            if (keys['w']) player.position.z -= speed;
            if (keys['s']) player.position.z += speed;
            if (keys['a']) player.position.x -= speed;
            if (keys['d']) player.position.x += speed;
            point.position.copy(player.position).y += 2;

            // Camera Setup
            const camOffset = isInsideGym ? 12 : 18;
            camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + camOffset, player.position.z + camOffset), 0.08);
            camera.lookAt(player.position);

            // Gym Logic
            const distToGym = player.position.distanceTo(new THREE.Vector3(-25, 0, -7));
            if (distToGym < 3.5) {
                isInsideGym = true; gymRoof.visible = false;
                if (hp < 100) hp += 0.15;
                document.getElementById('status').innerText = "RESTING: RECRUITING & HEALING";
                if (clique.length < 5 && Math.random() > 0.99) createCliqueMember();
            } else {
                isInsideGym = false; gymRoof.visible = true;
                document.getElementById('status').innerText = "STREETS: ACTIVE";
            }

            // Clique Follow Logic
            clique.forEach((member, i) => {
                const angle = (i / clique.length) * Math.PI * 2 + (Date.now() * 0.002);
                const targetPos = new THREE.Vector3(
                    player.position.x + Math.cos(angle) * 3,
                    0.9,
                    player.position.z + Math.sin(angle) * 3
                );
                member.position.lerp(targetPos, 0.1);
            });

            // Combat
            if (keys[' ']) {
                pBody.scale.set(1.4, 0.8, 1.4);
                enemies.forEach((en, i) => {
                    const d = player.position.distanceTo(en.position);
                    if (d < 3.5) {
                        en.userData.hp -= 4;
                        en.position.addScaledVector(new THREE.Vector3().subVectors(en.position, player.position).normalize(), 0.5);
                        // Clique helps
                        clique.forEach(m => m.position.lerp(en.position, 0.2));
                        
                        if (en.userData.hp <= 0) {
                            scene.remove(en);
                            enemies.splice(i, 1);
                            rep += 100;
                            document.getElementById('rep-display').innerText = `REP: ${rep}`;
                            setTimeout(spawnEnemy, 4000);
                        }
                    }
                });
            } else { pBody.scale.set(1, 1, 1); }

            // Enemy AI
            if (!isInsideGym) {
                enemies.forEach(en => {
                    const d = en.position.distanceTo(player.position);
                    if (d < 18) {
                        en.position.addScaledVector(new THREE.Vector3().subVectors(player.position, en.position).normalize(), 0.07);
                        if (d < 1.8) hp -= 0.3;
                    }
                });
            }

            document.getElementById('hp-fill').style.width = hp + "%";
            if (hp <= 0) location.reload();
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
