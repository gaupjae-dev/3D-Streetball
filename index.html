<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Underground 3D: Clique Wars</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #0f0; 
            background: rgba(0,0,0,0.85); padding: 20px; border: 2px solid #0f0;
            pointer-events: none; z-index: 10; width: 250px;
        }
        #mission-text { color: #ffff00; font-weight: bold; margin-top: 10px; display: none; }
        .hp-bar { width: 100%; height: 10px; background: #300; border: 1px solid #f00; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #f00; transition: 0.3s; }
        #rep-display { color: #00aaff; font-size: 14px; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 20px;">CLANDESTINE BOXING</div>
        <div id="rep-display">Reputation: 0</div>
        <div class="hp-bar"><div id="hp-fill"></div></div>
        <div id="mission-text">MISSION: CLEAR THE DOWNTOWN RING!</div>
        <p style="font-size: 11px; color: #888; margin-top: 15px;">WASD - Move | SPACE - Strike</p>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.Fog(0x020205, 5, 45);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const amb = new THREE.AmbientLight(0x404040, 1);
        scene.add(amb);
        const sun = new THREE.DirectionalLight(0x4444ff, 0.5);
        sun.position.set(5, 10, 5);
        scene.add(sun);

        // --- Game State ---
        let rep = 0;
        let hp = 100;
        let inMission = false;
        const buildings = [];
        const enemies = [];
        const clique = [];

        // --- Environment Creation ---
        // Ground with a "Grid" feel
        const floorGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, wireframe: false });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Create Downtown Buildings
        function makeBuilding(x, z, h, w) {
            const geo = new THREE.BoxGeometry(w, h, w);
            const mat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a });
            const b = new THREE.Mesh(geo, mat);
            b.position.set(x, h/2, z);
            scene.add(b);
            buildings.push(b);

            // Neon Trim
            const trimGeo = new THREE.BoxGeometry(w + 0.1, 0.2, w + 0.1);
            const trimMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
            const trim = new THREE.Mesh(trimGeo, trimMat);
            trim.position.set(x, h - 0.5, z);
            scene.add(trim);
        }

        // Downtown Perimeter
        for(let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            makeBuilding(Math.cos(angle) * 18, Math.sin(angle) * 18, 8 + Math.random() * 15, 5);
        }

        // --- Points of Interest ---
        // Mission Marker (The Ring)
        const markerGeo = new THREE.CylinderGeometry(4, 4, 0.5, 32);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.3 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(0, 0.1, 0);
        scene.add(marker);

        // --- Actors ---
        const player = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 0.8), new THREE.MeshStandardMaterial({color: 0x00aaff}));
        body.position.y = 0.9;
        player.add(body);
        scene.add(player);
        player.position.set(0, 0, 10);

        function spawnEnemy(x, z) {
            const e = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 0.8), new THREE.MeshStandardMaterial({color: 0xff3333}));
            e.position.set(x, 0.9, z);
            e.userData = { hp: 50 };
            scene.add(e);
            enemies.push(e);
        }

        // --- Input & Physics ---
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function checkCollision(obj, nextX, nextZ) {
            for (let b of buildings) {
                const bBox = new THREE.Box3().setFromObject(b);
                const pBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(nextX, 1, nextZ), 
                    new THREE.Vector3(1.2, 1.8, 1.2)
                );
                if (bBox.intersectsBox(pBox)) return true;
            }
            return false;
        }

        // --- Update Loop ---
        function update() {
            let moveX = 0;
            let moveZ = 0;
            const speed = 0.15;

            if (keys['w']) moveZ -= speed;
            if (keys['s']) moveZ += speed;
            if (keys['a']) moveX -= speed;
            if (keys['d']) moveX += speed;

            const nextX = player.position.x + moveX;
            const nextZ = player.position.z + moveZ;

            if (!checkCollision(player, nextX, nextZ)) {
                player.position.x = nextX;
                player.position.z = nextZ;
            }

            // Camera Setup
            camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 8, player.position.z + 10), 0.1);
            camera.lookAt(player.position);

            // Mission Logic
            const distToMarker = player.position.distanceTo(marker.position);
            if (distToMarker < 4 && !inMission) {
                document.getElementById('mission-text').style.display = 'block';
                if (keys[' ']) {
                    inMission = true;
                    spawnEnemy(3, -3);
                    spawnEnemy(-3, -3);
                    spawnEnemy(0, -5);
                }
            }

            // Combat logic
            if (keys[' ']) {
                body.scale.set(1.2, 1, 1.2);
                enemies.forEach((en, i) => {
                    if (player.position.distanceTo(en.position) < 2.5) {
                        en.userData.hp -= 2;
                        en.position.addScaledVector(new THREE.Vector3().subVectors(en.position, player.position).normalize(), 0.2);
                        if (en.userData.hp <= 0) {
                            scene.remove(en);
                            enemies.splice(i, 1);
                            rep += 10;
                            document.getElementById('rep-display').innerText = `Reputation: ${rep}`;
                        }
                    }
                });
            } else {
                body.scale.set(1, 1, 1);
            }

            // Enemy AI
            enemies.forEach(en => {
                const dist = en.position.distanceTo(player.position);
                if (dist < 10) {
                    const dir = new THREE.Vector3().subVectors(player.position, en.position).normalize();
                    en.position.addScaledVector(dir, 0.04);
                    if (dist < 1.5) {
                        hp -= 0.2;
                        document.getElementById('hp-fill').style.width = hp + "%";
                    }
                }
            });

            if (hp <= 0) {
                alert("Wasted! You lost your reputation.");
                location.reload();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            marker.rotation.y += 0.02; // Rotate the mission marker
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
