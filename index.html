<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Perfect Game - East Slums Update</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #map-icon {
            position: absolute; top: 20px; right: 20px;
            width: 80px; height: 80px;
            background: rgba(0,0,0,0.8); border: 3px solid #ffcc00;
            border-radius: 15px; cursor: pointer; color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; z-index: 10;
        }
        #ui { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 2px 2px 4px black; pointer-events: none; }
    </style>
</head>
<body>

    <div id="map-icon">MAP</div>
    <div id="ui">
        <b>WASD</b> to Move/Drive | <b>Q</b> to Punch | <b>Space</b> to Exit Car<br>
        <i>Drive Left to reach the East Slums</i>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 1. SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. WORLD STRUCTURE
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x2ecc71 }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // MAIN NORTH-SOUTH ROAD (The City Road)
        const mainRoad = new THREE.Mesh(new THREE.PlaneGeometry(20, 1000), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        mainRoad.rotation.x = -Math.PI / 2;
        mainRoad.position.y = 0.01;
        scene.add(mainRoad);

        // SECOND ROAD (To the East Slums - Heading Left)
        const eastRoad = new THREE.Mesh(new THREE.PlaneGeometry(400, 20), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        eastRoad.rotation.x = -Math.PI / 2;
        eastRoad.position.set(-200, 0.015, 0); // Spans from City to Slums
        scene.add(eastRoad);

        // 3. THE CITY (Center)
        const skyscraper = new THREE.Mesh(new THREE.BoxGeometry(15, 60, 15), new THREE.MeshStandardMaterial({ color: 0x7f8c8d }));
        skyscraper.position.set(0, 30, -30);
        scene.add(skyscraper);

        // 4. THE EAST SLUMS (200 steps West/Left)
        function createApartment(x, z) {
            const buildingGroup = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
            // C-Shape Apartment Layout
            const wing1 = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 10), wallMat);
            wing1.position.set(0, 7.5, 0);
            const wing2 = new THREE.Mesh(new THREE.BoxGeometry(10, 15, 30), wallMat);
            wing2.position.set(-10, 7.5, 10);
            const wing3 = new THREE.Mesh(new THREE.BoxGeometry(30, 15, 10), wallMat);
            wing3.position.set(0, 7.5, 20);
            
            buildingGroup.add(wing1, wing2, wing3);
            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);
        }

        // Build 2 O-Block Style Apartments
        createApartment(-250, -40);
        createApartment(-250, 40);

        // 5. CARS & PARKING
        const cars = [];
        const carColors = [0xff4757, 0x2ed573, 0xffa502];
        for(let i = 0; i < 3; i++) {
            const carGroup = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color: carColors[i] }));
            body.position.y = 0.5;
            const roof = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            roof.position.y = 1.3;
            carGroup.add(body, roof);
            carGroup.position.set(15 + (i * 6), 0, 10);
            scene.add(carGroup);
            cars.push({ mesh: carGroup });
        }

        // 6. PLAYER
        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x3498db }));
        player.position.set(10, 1, 15);
        scene.add(player);

        // 7. LIGHT & LOGIC
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(100, 100, 100);
        scene.add(light, new THREE.AmbientLight(0x404040));

        const keys = {};
        let currentCar = null;
        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

        function update() {
            const speed = 0.25;
            const rotSpeed = 0.04;

            if (currentCar) {
                if (keys['w']) currentCar.mesh.translateZ(-speed * 3);
                if (keys['s']) currentCar.mesh.translateZ(speed * 3);
                if (keys['a']) currentCar.mesh.rotation.y += rotSpeed;
                if (keys['d']) currentCar.mesh.rotation.y -= rotSpeed;
                player.position.copy(currentCar.mesh.position);
                if (keys[' ']) { currentCar = null; player.visible = true; player.position.x += 4; }
            } else {
                if (keys['w']) player.position.z -= speed;
                if (keys['s']) player.position.z += speed;
                if (keys['a']) player.position.x -= speed;
                if (keys['d']) player.position.x += speed;
                cars.forEach(car => {
                    if (player.position.distanceTo(car.mesh.position) < 3) {
                        currentCar = car;
                        player.visible = false;
                    }
                });
            }

            player.scale.z = keys['q'] ? 2 : 1;

            const camOffset = currentCar ? new THREE.Vector3(0, 15, 25) : new THREE.Vector3(0, 6, 12);
            const targetPos = currentCar ? currentCar.mesh.position : player.position;
            camera.position.lerp(new THREE.Vector3(targetPos.x + camOffset.x, targetPos.y + camOffset.y, targetPos.z + camOffset.z), 0.1);
            camera.lookAt(targetPos);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
