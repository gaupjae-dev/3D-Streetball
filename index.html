<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Perfect Game - Physics & Juice Update</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #000; }
        #ui { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 2px 2px 4px black; pointer-events: none; z-index: 10; }
        #map-icon { position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; background: rgba(0,0,0,0.8); border: 2px solid gold; border-radius: 10px; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; }
    </style>
</head>
<body>

    <div id="map-icon">MAP</div>
    <div id="ui">
        <b>WASD</b>: Move/Drive | <b>Q</b>: PUNCH (with FX!) | <b>Space</b>: Exit Car<br>
        <i>Physics Active: You can no longer walk through buildings.</i>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const collidableMeshList = [];

        // --- 2. WORLD & POIs (Empty Space Fix) ---
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x2ecc71 }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Roads
        const mainRoad = new THREE.Mesh(new THREE.PlaneGeometry(20, 1000), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        mainRoad.rotation.x = -Math.PI / 2;
        mainRoad.position.y = 0.01;
        scene.add(mainRoad);

        const eastRoad = new THREE.Mesh(new THREE.PlaneGeometry(400, 20), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        eastRoad.rotation.x = -Math.PI / 2;
        eastRoad.position.set(-200, 0.015, 0);
        scene.add(eastRoad);

        // Decorative POIs (Trees and Lamps along the road)
        for(let i = -150; i < 50; i += 40) {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), new THREE.MeshStandardMaterial({color: 0x8B4513}));
            const leaves = new THREE.Mesh(new THREE.SphereGeometry(3), new THREE.MeshStandardMaterial({color: 0x228B22}));
            leaves.position.y = 4;
            tree.add(trunk, leaves);
            tree.position.set(i, 0, 15);
            scene.add(tree);
        }

        // --- 3. BUILDINGS (With Collision) ---
        function createBuilding(w, h, d, x, z, color) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: color }));
            mesh.position.set(x, h/2, z);
            scene.add(mesh);
            collidableMeshList.push(mesh);
            return mesh;
        }

        const skyscraper = createBuilding(15, 60, 15, 0, -35, 0x7f8c8d);
        const slum1 = createBuilding(40, 15, 40, -250, -40, 0x95a5a6);
        const slum2 = createBuilding(40, 15, 40, -250, 40, 0x7f8c8d);

        // --- 4. CARS ---
        const cars = [];
        const carColors = [0xff0000, 0x00ff00, 0x0000ff];
        for(let i = 0; i < 3; i++) {
            const car = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.2, 5), new THREE.MeshStandardMaterial({ color: carColors[i] }));
            body.position.y = 0.6;
            car.add(body);
            car.position.set(15, 0, 10 + (i * 8));
            scene.add(car);
            cars.push({ mesh: car, radius: 2.5 });
        }

        // --- 5. PLAYER & PARTICLES (Juice) ---
        const player = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), new THREE.MeshStandardMaterial({ color: 0x3498db }));
        player.position.set(10, 1, 20);
        scene.add(player);

        const particles = [];
        function createPunchEffect(pos) {
            for(let i = 0; i < 10; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xffff00}));
                p.position.copy(pos);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5), life: 1.0 };
                scene.add(p);
                particles.push(p);
            }
        }

        // --- 6. LOGIC & PHYSICS ---
        const keys = {};
        let currentCar = null;
        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

        function checkCollision(newPos, size) {
            const playerBB = new THREE.Box3().setFromCenterAndSize(newPos, new THREE.Vector3(size, size, size));
            for (let mesh of collidableMeshList) {
                const meshBB = new THREE.Box3().setFromObject(mesh);
                if (playerBB.intersectsBox(meshBB)) return true;
            }
            return false;
        }

        function update() {
            const speed = 0.3;
            let moveVec = new THREE.Vector3(0, 0, 0);

            if (currentCar) {
                if (keys['w']) currentCar.mesh.translateZ(-speed * 3);
                if (keys['s']) currentCar.mesh.translateZ(speed * 3);
                if (keys['a']) currentCar.mesh.rotation.y += 0.05;
                if (keys['d']) currentCar.mesh.rotation.y -= 0.05;
                player.position.copy(currentCar.mesh.position);
                if (keys[' ']) { currentCar = null; player.visible = true; player.position.x += 5; }
            } else {
                if (keys['w']) moveVec.z -= speed;
                if (keys['s']) moveVec.z += speed;
                if (keys['a']) moveVec.x -= speed;
                if (keys['d']) moveVec.x += speed;

                const nextPos = player.position.clone().add(moveVec);
                if (!checkCollision(nextPos, 1.2)) {
                    player.position.copy(nextPos);
                }

                // Interaction
                cars.forEach(car => {
                    if (player.position.distanceTo(car.mesh.position) < 3) {
                        currentCar = car;
                        player.visible = false;
                    }
                });

                // Punch (Feedback/Juice)
                if (keys['q']) {
                    player.scale.z = 2;
                    if (Math.random() > 0.8) createPunchEffect(player.position.clone().add(new THREE.Vector3(0, 1, -2)));
                } else {
                    player.scale.z = 1;
                }
            }

            // Update Particles
            for(let i = particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.life -= 0.02;
                p.material.opacity = p.userData.life;
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            const target = currentCar ? currentCar.mesh.position : player.position;
            camera.position.lerp(new THREE.Vector3(target.x, target.y + 10, target.z + 20), 0.1);
            camera.lookAt(target);
        }

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(50, 100, 50);
        scene.add(light, new THREE.AmbientLight(0x606060));

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
