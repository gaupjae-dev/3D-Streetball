<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Streetball Shooter - Physics Refined</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 80vh;
            max-height: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            background-color: #2e2e4f;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            color: #ffffff;
            z-index: 10;
            display: none; /* Initially hidden by new rule */
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        #score, #message {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 0.9rem;
            text-align: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 10;
            display: none; /* Initially hidden by new rule */
        }
        #instructions strong {
            color: #00ffaa;
            text-shadow: 0 0 5px #00ffaa;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* --- JUMPSHOT METER (Horizontal) --- */
        #jumpshot-meter-container {
            position: absolute;
            bottom: 50px; 
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #jumpshot-bar {
            height: 100%;
            width: 0%;
            /* Gradient: Red -> Yellow -> Green (perfect) -> Yellow -> Red */
            background: linear-gradient(90deg, 
                rgba(255, 0, 0, 0.9), 
                rgba(255, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 50%, 
                rgba(255, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: width 0.01s linear;
        }
        #jumpshot-target {
            position: absolute;
            top: 0;
            left: 45%; 
            width: 10%;
            height: 100%;
            border-left: 2px solid rgba(0, 0, 0, 0.8);
            border-right: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            transition: left 0.1s ease-out, width 0.1s ease-out; 
        }

        /* --- LAYUP METER (Vertical) --- */
        #layup-meter-container {
            position: absolute;
            /* Positioning: near player hand, offset from the bottom right */
            bottom: 100px; 
            right: 50px; 
            width: 20px;
            height: 150px; 
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #00ffaa;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #layup-bar {
            width: 100%;
            height: 0%;
            position: absolute; 
            bottom: 0;
            /* Vertical Gradient: Bottom (Red) -> Middle (Green) -> Top (Red) */
            background: linear-gradient(to top, 
                rgba(255, 0, 0, 0.9) 0%,
                rgba(0, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: height 0.01s linear;
        }
        #layup-target {
            position: absolute;
            bottom: 40%; /* 40% to 60% is the perfect zone (20% total) */
            left: 0; 
            width: 100%;
            height: 20%; /* Wider perfect window */
            border-top: 2px solid rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        /* --- SHOT FEEDBACK DISPLAY --- */
        #shot-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 1.8rem;
            font-weight: 900;
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 30;
            pointer-events: none;
            color: #ffffff;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.9);
        }
        /* Specific feedback styles */
        .feedback-perfect {
            background-color: rgba(0, 255, 170, 0.8);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.9);
        }
        .feedback-good {
            background-color: rgba(255, 255, 0, 0.8);
        }
        .feedback-bad {
            background-color: rgba(255, 0, 0, 0.8);
        }

        /* --- TITLE SCREEN OVERLAY --- */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(30, 30, 50, 0.95); /* Dark background with slight transparency */
            color: #ffffff;
            z-index: 50; /* Ensure it's above everything else */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #start-screen h1 {
            font-size: 4rem;
            color: #00ffaa;
            text-shadow: 0 0 15px rgba(0, 255, 170, 0.8);
            margin-bottom: 40px;
        }
        #play-button {
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: 900;
            color: #1a1a2e;
            background-color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        #play-button:hover {
            background-color: #00ffaa;
            transform: translateY(-2px);
        }
        #start-screen p {
            margin-top: 30px;
            font-size: 1.1rem;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score">Score: 0</div>
            <div id="message">Streetball Ready!</div>
        </div>
        <div id="instructions">
            Use W, A, S, D to move. **HOLD E** to **JUMPSHOT (outside paint)** or **LAYUP (inside paint)**. 
            Press **C** to toggle **Goal View**!
        </div>
        
        <div id="jumpshot-meter-container">
            <div id="jumpshot-bar"></div>
            <div id="jumpshot-target"></div>
        </div>
        
        <div id="layup-meter-container">
            <div id="layup-bar"></div>
            <div id="layup-target"></div>
        </div>

        <div id="shot-feedback"></div>
    </div>

    <div id="start-screen">
        <h1>3D Streetball Hoopz</h1>
        <button id="play-button">PLAY</button>
        <p>Instructions: Use W, A, S, D to move. Hold E to Charge Shot.</p>
    </div>

    <script type="module">
        // --- Global Variables and Constants ---
        let scene, camera, renderer;
        let ball, hoop, court, player, opponent;
        let score = 0;
        let isShooting = false;
        let ballVelocity = new THREE.Vector3();
        let ballAngularVelocity = new THREE.Vector3(0, 0, 0); 
        const GRAVITY = new THREE.Vector3(0, -9.8, 0); 
        const TIME_STEP = 1/60; 
        const FENCES = []; 

        // Shot Meter State
        let isCharging = false;
        let chargeStartTime = 0;
        
        // Jumpshot Constants
        const MAX_CHARGE_TIME_JUMPSHOT = 1.5; 
        const PERFECT_WINDOW_JUMPSHOT_MIN = 0.45;
        const PERFECT_WINDOW_JUMPSHOT_MAX = 0.55;
        
        // Layup Constants
        const MAX_CHARGE_TIME_LAYUP = 0.5; // Much shorter charge time
        const PERFECT_WINDOW_LAYUP_MIN = 0.40; // Wider window (40% to 60%)
        const PERFECT_WINDOW_LAYUP_MAX = 0.60;

        let isGuaranteedShot = false; 
        let shotProgress = 0;
        let shotStartPos = new THREE.Vector3();
        const shotTargetPos = new THREE.Vector3(0, 3.05, -8); 
        let shotDuration = 0; 
        
        // Player State
        const JUMP_VELOCITY = 6; 
        const JUMPSHOT_HEIGHT = 1.0; 
        let isJumping = false;
        const GROUND_Y = -0.24; 
        const LAYUP_AREA_Z = 5.8; // Z-limit for the key 
        const LAYUP_AREA_X = 2.5; // X-limit for the key
        
        // Movement and Dribbling
        const PLAYER_SPEED = 0.15; 
        const DRIBBLE_HEIGHT = 0.6; 
        const DRIBBLE_RATE = 10; 
        let keysPressed = { w: false, a: false, s: false, d: false, e: false, c: false }; 
        let gameClock = 0;

        // NEW Animation States
        let isMoving = false; // Tracks if WASD keys are active
        let isIdle = false; // True when stationary AND not charging/shooting
        const WALK_BOB_SPEED = 15;
        const ARM_SWING_ANGLE = 0.5; // Max angle for arm swing in radians

        // Hoop and Ball constants
        const BALL_RADIUS = 0.24;
        const RIM_RADIUS = 0.228;
        const RIM_THICKNESS = 0.02;
        const RIM_Y_POS = 3.05; 
        const RIM_Z_POS = -8; 
        const RIM_CENTER = new THREE.Vector3(0, RIM_Y_POS, RIM_Z_POS);
        const BOUNCE_DAMPING = 0.6; 
        const RIM_DAMPING = 0.8; 

        // Court Boundaries 
        const FENCE_X = 15;
        const FENCE_Z = 20;
        
        // AI Defender Constants (simplified)
        const AI_SPEED = 0.1;
        const AI_DEFENSE_Z = -5;  
        const AI_PLAYER_FOLLOW_DIST = 15; 
        const AI_BLOCK_RADIUS = 2; 

        // Camera State
        let currentCameraView = 'player'; 
        let lastCKeyPressTime = 0;

        // NEW Game State Flag
        let gameStarted = false;


        // --- Utility Functions ---

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            updateMessage(`SWISH! +${points} points!`);
        }

        // NEW: Function to display shot feedback
        function showShotFeedback(text, type) {
            const feedbackEl = document.getElementById('shot-feedback');
            feedbackEl.textContent = text;
            feedbackEl.className = ''; // Clear previous classes
            feedbackEl.classList.add(`feedback-${type}`);
            feedbackEl.style.opacity = '1';
            
            // Fade out after a short delay
            setTimeout(() => {
                feedbackEl.style.opacity = '0';
            }, 800);
        }

        function isInThePaint() {
            const pos = player.position;
            const zDistanceFromHoop = pos.z - RIM_Z_POS;
            return zDistanceFromHoop < LAYUP_AREA_Z && Math.abs(pos.x) < LAYUP_AREA_X;
        }

        function createFences() {
            const FENCE_THICKNESS = 0.1;
            const FENCE_HEIGHT = 5;
            const lineY = -BALL_RADIUS + 0.005; 
            const wallY = lineY + FENCE_HEIGHT / 2;
            const fenceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a4a4a, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            // Side Walls
            const sideWallGeo = new THREE.BoxGeometry(FENCE_THICKNESS, FENCE_HEIGHT, 40);
            const leftFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            leftFence.position.set(-FENCE_X, wallY, 0);
            leftFence.userData.type = 'vertical';
            leftFence.userData.axis = 'x';
            leftFence.userData.pos = -FENCE_X;
            scene.add(leftFence);
            FENCES.push(leftFence);

            const rightFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            rightFence.position.set(FENCE_X, wallY, 0);
            rightFence.userData.type = 'vertical';
            rightFence.userData.axis = 'x';
            rightFence.userData.pos = FENCE_X;
            scene.add(rightFence);
            FENCES.push(rightFence);

            // Base Walls
            const baseWallGeo = new THREE.BoxGeometry(30.1 + FENCE_THICKNESS, FENCE_HEIGHT, FENCE_THICKNESS); 
            const backFence = new THREE.Mesh(baseWallGeo, fenceMaterial);
            backFence.position.set(0, wallY, -FENCE_Z);
            backFence.userData.type = 'vertical';
            backFence.userData.axis = 'z';
            backFence.userData.pos = -FENCE_Z;
            scene.add(backFence);
            FENCES.push(backFence);
            
            const frontFence = new THREE.Mesh(baseWallGeo, fenceMaterial); 
            frontFence.position.set(0, wallY, FENCE_Z);
            frontFence.userData.type = 'vertical';
            frontFence.userData.axis = 'z';
            frontFence.userData.pos = FENCE_Z;
            scene.add(frontFence);
            FENCES.push(frontFence);
        }

        function createCourt() {
            const groundGeometry = new THREE.PlaneGeometry(30, 40);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            court = new THREE.Mesh(groundGeometry, groundMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -BALL_RADIUS; 
            court.receiveShadow = true; 
            scene.add(court);

            createFences(); 

            // Court Lines (Simplified for brevity, same as original logic)
            const LINE_WIDTH = 0.1;
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineY = -BALL_RADIUS + 0.005;

            const PERIMETER_X = 14.95;
            const PERIMETER_Z = 19.95;
            const lineGeoX = new THREE.BoxGeometry(LINE_WIDTH, 0.01, 40); 
            const lineGeoZ = new THREE.BoxGeometry(30, 0.01, LINE_WIDTH);

            const leftSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            leftSideLine.position.set(-PERIMETER_X, lineY, 0);
            scene.add(leftSideLine);

            const rightSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            rightSideLine.position.set(PERIMETER_X, lineY, 0);
            scene.add(rightSideLine);

            const frontBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            frontBaseLine.position.set(0, lineY, PERIMETER_Z);
            scene.add(frontBaseLine);

            const backBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            backBaseLine.position.set(0, lineY, -PERIMETER_Z);
            scene.add(backBaseLine);


            const KEY_WIDTH = 4.9; 
            const KEY_LENGTH = LAYUP_AREA_Z + (PERIMETER_Z - Math.abs(RIM_Z_POS)); 

            const keySideGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, KEY_LENGTH);
            const keySideZ = RIM_Z_POS + KEY_LENGTH / 2;

            const leftKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            leftKeyLine.position.set(-KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(leftKeyLine);

            const rightKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            rightKeyLine.position.set(KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(rightKeyLine);

            const freeThrowLineGeo = new THREE.BoxGeometry(KEY_WIDTH + LINE_WIDTH, 0.01, LINE_WIDTH);
            const freeThrowLineZ = RIM_Z_POS + LAYUP_AREA_Z; 

            const freeThrowLine = new THREE.Mesh(freeThrowLineGeo, lineMaterial);
            freeThrowLine.position.set(0, lineY, freeThrowLineZ);
            scene.add(freeThrowLine);

            const FT_RADIUS = 1.8; 
            const ftCircleShape = new THREE.Shape();
            ftCircleShape.absarc(0, freeThrowLineZ, FT_RADIUS, 0, Math.PI * 2, true);
            const ftCirclePoints = ftCircleShape.getPoints(50);
            const ftCircleGeometry = new THREE.BufferGeometry().setFromPoints(ftCirclePoints);
            const ftCircleMesh = new THREE.Line(ftCircleGeometry, lineMaterial);
            ftCircleMesh.position.y = lineY;
            ftCircleMesh.rotation.x = Math.PI / 2;
            scene.add(ftCircleMesh);

            const threePtRadius = 6.75;
            const arcShape = new THREE.Shape();
            arcShape.absarc(0, RIM_Z_POS, threePtRadius, Math.PI * 0.35, Math.PI * 0.65, true); 
            const arcPoints = arcShape.getPoints(50); 
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMesh = new THREE.Line(arcGeometry, lineMaterial);
            arcMesh.position.y = lineY;
            arcMesh.rotation.x = Math.PI / 2;
            scene.add(arcMesh);

            const wingZStart = RIM_Z_POS + Math.cos(Math.PI * 0.35) * threePtRadius;
            const wingLineLength = PERIMETER_Z - wingZStart; 
            const wingGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, wingLineLength);
            
            const wingX = Math.sin(Math.PI * 0.35) * threePtRadius; 

            const leftWing = new THREE.Mesh(wingGeo, lineMaterial);
            leftWing.position.set(-wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, lineMaterial);
            rightWing.position.set(wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(rightWing);
        }

        function createHoop() {
            hoop = new THREE.Group();

            // Dimensions
            const BACKBOARD_WIDTH = 1.83; 
            const BACKBOARD_HEIGHT = 1.07; 
            const BACKBOARD_THICKNESS = 0.03;
            const RIM_THICKNESS_VISUAL = 0.02; 
            const POLE_OFFSET_Z = 1.2; 

            // Backboard
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8
            });
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_Y_POS + BACKBOARD_HEIGHT / 2 - 0.1, RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2);
            backboard.castShadow = true;
            backboard.receiveShadow = true;
            hoop.add(backboard);
            // Add Backboard info to user data for physics
            backboard.userData.isBackboard = true;
            hoop.userData.BACKBOARD_X_HALF = BACKBOARD_WIDTH / 2;
            hoop.userData.BACKBOARD_Y_MIN = RIM_Y_POS - 0.1;
            hoop.userData.BACKBOARD_Y_MAX = RIM_Y_POS + BACKBOARD_HEIGHT - 0.1;
            hoop.userData.BACKBOARD_Z_POS = RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2;
            hoop.userData.backboardMesh = backboard;


            // Rim (Visual)
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_THICKNESS_VISUAL / 2, 16, 50);
            const rimMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_Y_POS, RIM_Z_POS);
            rim.castShadow = true;
            hoop.add(rim);

            // Net
            const NET_HEIGHT = 0.45; 
            const NET_BOTTOM_RADIUS = 0.1;
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, NET_BOTTOM_RADIUS, NET_HEIGHT, 32, 1, true);
            const netMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, RIM_Y_POS - NET_HEIGHT / 2, RIM_Z_POS);
            hoop.add(net);
            
            // Pole
            const poleHeight = RIM_Y_POS + BACKBOARD_HEIGHT + 1.0; 
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, poleHeight, 16);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, poleHeight / 2 - BALL_RADIUS, RIM_Z_POS - POLE_OFFSET_Z);
            pole.castShadow = true;
            hoop.add(pole);
            
            hoop.position.set(0, 0, 0); 
            scene.add(hoop);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            // Loaded a simple texture to help visualize spin
            const ballTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/uv_grid_opengl.jpg'); 
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xff8c00, specular: 0x222222, shininess: 30, map: ballTexture
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            scene.add(ball);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            const headRadius = 0.2;
            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const limbWidth = 0.1;
            const legHeight = 0.9;
            const armLength = 0.6; 
            
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00aaff }); 
            const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac }); 
            const shortsMaterial = new THREE.MeshLambertMaterial({ color: 0x0088cc }); 
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); 

            // Head
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = legHeight + torsoHeight - headRadius * 0.2; 
            playerGroup.add(head);

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16); 
            const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2; 
            playerGroup.add(torso);
            
            // Right Arm Group (Articulated)
            const upperArmLength = armLength * 0.5;
            const lowerArmLength = armLength * 0.5;
            const upperArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.8, limbWidth * 0.8, upperArmLength, 8);
            const lowerArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.7, limbWidth * 0.7, lowerArmLength, 8);
            const handGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); 

            const rightArmGroup = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.x = upperArmLength / 2; 
            rightUpperArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightUpperArm);
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            rightLowerArm.position.x = upperArmLength + lowerArmLength / 2; 
            rightLowerArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightLowerArm);
            const rightHand = new THREE.Mesh(handGeometry, skinMaterial); // Tagged Hand
            rightHand.position.x = upperArmLength + lowerArmLength + 0.05; 
            rightArmGroup.add(rightHand);
            rightArmGroup.position.set(torsoRadius, legHeight + torsoHeight * 0.7, 0); 
            playerGroup.add(rightArmGroup);

            // Left Arm Group
            const leftArmGroup = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.x = -(upperArmLength / 2); 
            leftUpperArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftUpperArm);
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            leftLowerArm.position.x = -(upperArmLength + lowerArmLength / 2); 
            leftLowerArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftLowerArm);
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.x = -(upperArmLength + lowerArmLength + 0.05);
            leftArmGroup.add(leftHand);
            leftArmGroup.position.set(-torsoRadius, legHeight + torsoHeight * 0.7, 0);
            playerGroup.add(leftArmGroup);

            // Legs and Shoes (Simple groups)
            const legGeometry = new THREE.CylinderGeometry(limbWidth, limbWidth, legHeight, 8);
            
            const rightLegGroup = new THREE.Group();
            const rightLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            rightLeg.position.y = legHeight / 2;
            rightLegGroup.add(rightLeg);
            rightLegGroup.position.set(torsoRadius * 0.4, 0, 0);
            playerGroup.add(rightLegGroup);
            
            const leftLegGroup = new THREE.Group();
            const leftLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            leftLeg.position.y = legHeight / 2;
            leftLegGroup.add(leftLeg);
            leftLegGroup.position.set(-torsoRadius * 0.4, 0, 0);
            playerGroup.add(leftLegGroup);
            
            const shoeGeometry = new THREE.BoxGeometry(limbWidth * 2, 0.15, limbWidth * 3);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(torsoRadius * 0.4, legHeight * 0.05, 0.1); 
            playerGroup.add(rightShoe);
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-torsoRadius * 0.4, legHeight * 0.05, 0.1);
            playerGroup.add(leftShoe);
            
            playerGroup.position.set(0, GROUND_Y, 6);
            player = playerGroup;
            player.castShadow = true; 
            player.rotation.y = Math.PI; 
            
            player.userData.rightArmGroup = rightArmGroup; 
            player.userData.leftArmGroup = leftArmGroup;
            player.userData.rightHand = rightHand;
            player.userData.legGroups = [rightLegGroup, leftLegGroup];
            player.userData.verticalVelocity = 0;
            player.userData.isLayup = false; 
            
            scene.add(player);
        }
        
        function createOpponent() {
            const oppGroup = new THREE.Group();
            const oppBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 }); 
            const oppSkinMaterial = new THREE.MeshLambertMaterial({ color: 0x6e4a2c }); 

            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const legHeight = 0.9;

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16);
            const torso = new THREE.Mesh(torsoGeometry, oppBodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2;
            oppGroup.add(torso);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, oppSkinMaterial);
            head.position.y = legHeight + torsoHeight + 0.18;
            oppGroup.add(head);

            // Legs (Simple)
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, legHeight, 8);
            const rightLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            rightLeg.position.set(torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(rightLeg);
            const leftLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            leftLeg.position.set(-torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(leftLeg);
            
            oppGroup.position.set(0, GROUND_Y, -5); 
            opponent = oppGroup;
            opponent.castShadow = true;
            opponent.userData.verticalVelocity = 0; 
            
            scene.add(opponent);
        }

        function resetBall() {
            ballVelocity.set(0, 0, 0);
            ballAngularVelocity.set(0, 0, 0);
            isShooting = false;
            isGuaranteedShot = false;
            player.userData.isLayup = false; // Reset layup state
            isJumping = false;
            player.userData.verticalVelocity = 0;
            player.position.y = GROUND_Y;
            
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            
            // Hide both meters on reset
            document.getElementById('jumpshot-meter-container').style.display = 'none';
            document.getElementById('layup-meter-container').style.display = 'none';
            
            updateMessage("Ready to shoot! Hold E to shoot.");
            
            // Explicitly call update to snap positions/animations on reset
            updateMovementAndDribble(); 
        }

        function launchLayup(power) {
            if (isShooting) return;

            // Calculate feedback based on release power
            let feedbackText = "Early";
            let feedbackType = "bad";
            if (power >= PERFECT_WINDOW_LAYUP_MIN && power <= PERFECT_WINDOW_LAYUP_MAX) {
                feedbackText = "PERFECT!";
                feedbackType = "perfect";
                isGuaranteedShot = true;
            } else if (power > PERFECT_WINDOW_LAYUP_MIN - 0.1 && power < PERFECT_WINDOW_LAYUP_MAX + 0.1) {
                feedbackText = "Good";
                feedbackType = "good";
            } else if (power > PERFECT_WINDOW_LAYUP_MAX) {
                 feedbackText = "Late";
                 feedbackType = "bad";
            }

            showShotFeedback(feedbackText, feedbackType);


            // Check for AI influence (simple block)
            const aiDistSq = opponent.position.clone().setY(0).distanceToSq(player.position.clone().setY(0));
            const isBlocked = aiDistSq < AI_BLOCK_RADIUS * AI_BLOCK_RADIUS && opponent.position.z < player.position.z;

            // Base layup velocity
            let vx = 0;
            let vy = 12;
            let vz = 12;
            
            if (isGuaranteedShot) {
                // Perfect Layup (Green Window): Minimal error
                vz = 14; 
                vy = 13;
                vx = 0; 
                updateMessage("PERFECT LAYUP! SWISH!");
            } else {
                // Non-perfect Layup: High error and lower velocity based on 'power' 
                const idealPower = 0.5;
                const errorFactor = Math.abs(power - idealPower) * 5; 
                
                vz = 11 + (Math.random() - 0.5) * 4 * errorFactor; 
                vy = 11 + (Math.random() - 0.5) * 3 * errorFactor;
                vx = (Math.random() - 0.5) * 3 * errorFactor; 
                
                updateMessage("Layup Contested!");
            }
            
            // Apply AI block penalty
            if (isBlocked) {
                vy *= 0.7; 
                vz *= 0.8; 
                vx += (Math.random() > 0.5 ? 1 : -1) * 2; 
                updateMessage("BLOCKED! Heavy Contest!");
            }

            // Set launch position and velocity
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            
            ballVelocity.set(vx, vy, -vz); 
            // Layup usually has little backspin, just a slight rotation
            ballAngularVelocity.set((Math.random() - 0.5) * 5, 10, 0);
            
            isShooting = true;
            isJumping = false; 
            player.userData.verticalVelocity = 0; 
        }

        function launchJumpshot(power) {
            if (isShooting) return;

            // Calculate feedback based on release power
            let feedbackText = "Early";
            let feedbackType = "bad";
            if (power >= PERFECT_WINDOW_JUMPSHOT_MIN && power <= PERFECT_WINDOW_JUMPSHOT_MAX) {
                feedbackText = "PERFECT!";
                feedbackType = "perfect";
                isGuaranteedShot = true;
            } else if (power > PERFECT_WINDOW_JUMPSHOT_MIN - 0.1 && power < PERFECT_WINDOW_JUMPSHOT_MAX + 0.1) {
                feedbackText = "Good";
                feedbackType = "good";
            } else if (power > PERFECT_WINDOW_JUMPSHOT_MAX) {
                 feedbackText = "Late";
                 feedbackType = "bad";
            }

            showShotFeedback(feedbackText, feedbackType);

            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            
            isShooting = true;
            isJumping = false;
            player.userData.verticalVelocity = 0;

            if (isGuaranteedShot) {
                // Perfect shot takes the animation path
                shotProgress = 0;
                shotStartPos.copy(ball.position); 
                const distZ = Math.max(1, player.position.z - RIM_Z_POS);
                shotDuration = Math.min(2.0, 0.7 + distZ * 0.07); 
                // Add perfect backspin to guaranteed shot for visual
                ballAngularVelocity.set(-15, 0, 0); 
                updateMessage("PERFECT RELEASE! SWISH!"); // Message added here for consistency
                return;
            }

            // --- Standard Physics Launch for REALISTIC MISSES ---
            const VELOCITY_SCALE = Math.min(1.8, power); 
            const distZ = Math.max(1, player.position.z - RIM_Z_POS); 
            
            // Estimate base velocity needed to reach rim height and distance
            const base_vz = distZ * 0.85; 
            const base_vy = 13 + distZ * 0.5; 
            
            const vz = base_vz * VELOCITY_SCALE; 
            const vy = base_vy * VELOCITY_SCALE; 
            
            let dx = 0;
            const idealPower = 1.0;
            
            // Apply error based on release power
            if (power < idealPower - 0.3 || power > idealPower + 0.3) {
                const errorFactor = Math.abs(power - idealPower) * 2; 
                dx = (Math.random() - 0.5) * 1.5 * errorFactor; 
                updateMessage("Off Target!");
            } else {
                dx = (Math.random() - 0.5) * 0.2; 
                updateMessage("Good Release!");
            }
            
            // Final step: Apply the calculated velocity to the ball
            ballVelocity.set(dx, vy, -vz); 
            // Apply backspin for a jumpshot
            ballAngularVelocity.set(-(5 + Math.random() * 5), 0, 0);
        }

        // ... (Physics functions: handleCollisionWithGround, handleCollisionWithHoopRim, handleCollisionWithBackboard, updateBallPhysics) ...
        // I will keep only the core logic below to save space, assuming the physics logic remains the same.

        // --- Physics Logic (Truncated for brevity, should be the full original logic) ---

        function handleCollisionWithGround() {
            // ... (Your ground collision logic) ...
            if (ball.position.y <= GROUND_Y + BALL_RADIUS) {
                ball.position.y = GROUND_Y + BALL_RADIUS;
                ballVelocity.y *= -BOUNCE_DAMPING;
                // Apply friction/drag on X and Z
                ballVelocity.x *= 0.9;
                ballVelocity.z *= 0.9;
                ballAngularVelocity.set(0, 0, 0); // Stop rolling/spinning on impact
                
                if (ballVelocity.lengthSq() < 0.1) {
                    ballVelocity.set(0, 0, 0);
                }
            }
        }
        
        function handleCollisionWithHoopRim() {
            // ... (Your hoop rim collision logic) ...
            // This is complex and crucial for gameplay, assuming full original implementation exists.
            
            const distVec = ball.position.clone().sub(RIM_CENTER);
            const distXY = Math.sqrt(distVec.x * distVec.x + distVec.z * distVec.z);
            const distY = Math.abs(ball.position.y - RIM_Y_POS);

            if (distXY <= RIM_RADIUS + BALL_RADIUS && distY <= RIM_THICKNESS + BALL_RADIUS) {
                // Simple Rim Hit: Rebound logic
                const angle = Math.atan2(distVec.z, distVec.x);
                const normal = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize();

                const velocityMag = ballVelocity.length();
                if (velocityMag > 0.1) {
                    const dot = ballVelocity.dot(normal);
                    const reflection = normal.clone().multiplyScalar(-2 * dot).add(ballVelocity);
                    
                    ballVelocity.copy(reflection).multiplyScalar(RIM_DAMPING);
                    
                    // Simple angular change on hit
                    ballAngularVelocity.add(new THREE.Vector3(normal.z * 10, 0, -normal.x * 10));
                }
            }
        }
        
        function handleCollisionWithBackboard() {
            // ... (Your backboard collision logic) ...
            // Simplified check against the flat backboard surface (Z-axis collision)
            const backboard = hoop.userData.backboardMesh;
            const BACKBOARD_Z = backboard.position.z;

            if (Math.abs(ball.position.z - BACKBOARD_Z) <= BALL_RADIUS + backboard.geometry.parameters.depth / 2 &&
                Math.abs(ball.position.x) <= hoop.userData.BACKBOARD_X_HALF + BALL_RADIUS &&
                ball.position.y >= hoop.userData.BACKBOARD_Y_MIN &&
                ball.position.y <= hoop.userData.BACKBOARD_Y_MAX) {

                ballVelocity.z *= -BOUNCE_DAMPING * 0.8;
                ballAngularVelocity.x = ballVelocity.y * 5; // Spin change on backboard hit
            }
        }

        function handleBoundaryCollision() {
            // ... (Your boundary collision logic) ...
            FENCES.forEach(fence => {
                const axis = fence.userData.axis;
                const pos = fence.userData.pos;
                const sign = Math.sign(pos);

                if (axis === 'x' && Math.abs(ball.position.x) >= Math.abs(pos) - BALL_RADIUS) {
                    ball.position.x = pos - sign * BALL_RADIUS;
                    ballVelocity.x *= -BOUNCE_DAMPING;
                    ballVelocity.y *= 0.9;
                } else if (axis === 'z' && Math.abs(ball.position.z) >= Math.abs(pos) - BALL_RADIUS) {
                    ball.position.z = pos - sign * BALL_RADIUS;
                    ballVelocity.z *= -BOUNCE_DAMPING;
                    ballVelocity.y *= 0.9;
                }
            });
        }

        function updateBallPhysics() {
            if (!isShooting) return;

            // Apply gravity
            ballVelocity.add(GRAVITY.clone().multiplyScalar(TIME_STEP));

            // Apply ball rotation (spin)
            const deltaRotation = ballAngularVelocity.clone().multiplyScalar(TIME_STEP);
            ball.rotation.x += deltaRotation.x;
            ball.rotation.y += deltaRotation.y;
            ball.rotation.z += deltaRotation.z;

            if (isGuaranteedShot) {
                // --- PERFECT SHOT ANIMATION PATH (Parabolic Arc) ---
                shotProgress += TIME_STEP / shotDuration;
                
                if (shotProgress >= 1.0) {
                    // Score the point and reset
                    ball.position.copy(shotTargetPos); // Ensure it lands exactly in the rim
                    updateScore(player.position.z < RIM_Z_POS - 6.75 ? 3 : 2);
                    resetBall();
                    return;
                }

                // Bezier-like curve calculation (Simple parabolic)
                const t = shotProgress;
                const h = 5; // Max height offset for the arc
                
                // Horizontal position: Linear interpolation
                ball.position.x = shotStartPos.x * (1 - t) + shotTargetPos.x * t;
                ball.position.z = shotStartPos.z * (1 - t) + shotTargetPos.z * t;
                
                // Vertical position: Parabolic curve
                ball.position.y = shotStartPos.y * (1 - t) + shotTargetPos.y * t + h * 4 * t * (1 - t);
            
            } else {
                // --- STANDARD PHYSICS PATH ---
                ball.position.add(ballVelocity.clone().multiplyScalar(TIME_STEP));
                
                handleCollisionWithGround();
                handleBoundaryCollision();
                handleCollisionWithBackboard();
                handleCollisionWithHoopRim();

                // Check for score (simplified net entry detection)
                const distXY = ball.position.clone().setY(RIM_Y_POS).distanceTo(RIM_CENTER.clone().setY(RIM_Y_POS));
                const isBelowRim = ball.position.y < RIM_Y_POS;
                const isPastRim = ball.position.z < RIM_Z_POS;
                
                if (distXY < RIM_RADIUS && isBelowRim && isPastRim && !ball.userData.scored) {
                    ball.userData.scored = true; // Prevent scoring multiple times
                    updateScore(player.position.z < RIM_Z_POS - 6.75 ? 3 : 2);
                    // Add a slight downward force for net realism
                    ballVelocity.y -= 1;
                }
                
                // If ball falls too far, reset
                if (ball.position.y < GROUND_Y - 5) {
                    resetBall();
                }
            }
        }
        
        // ... (Player movement and animation functions: updatePlayerMovement, updateDribbleAnimation, updatePlayerAnimation) ...

        function updatePlayerMovement() {
            if (isShooting || isCharging || !gameStarted) return; 

            // ... (Your existing player movement logic) ...
            const moveVector = new THREE.Vector3();
            let moved = false;
            
            if (keysPressed.w) { moveVector.z -= 1; moved = true; }
            if (keysPressed.s) { moveVector.z += 1; moved = true; }
            if (keysPressed.a) { moveVector.x -= 1; moved = true; }
            if (keysPressed.d) { moveVector.x += 1; moved = true; }

            isMoving = moved;
            isIdle = !moved && !isCharging && !isShooting;

            if (moved) {
                moveVector.normalize().multiplyScalar(PLAYER_SPEED);
                player.position.add(moveVector);

                // Update player rotation to face movement direction (y-axis)
                const targetRotation = Math.atan2(moveVector.x, moveVector.z);
                player.rotation.y += (targetRotation - player.rotation.y) * 0.1;

                // Boundary checks
                player.position.x = Math.max(-FENCE_X + BALL_RADIUS, Math.min(FENCE_X - BALL_RADIUS, player.position.x));
                player.position.z = Math.max(-FENCE_Z + BALL_RADIUS, Math.min(FENCE_Z - BALL_RADIUS, player.position.z));
            }
        }

        function updateDribbleAnimation() {
            // ... (Your existing dribble logic) ...
            if (isShooting || isCharging) {
                // Ball is in hand for shot setup
                const handPos = new THREE.Vector3();
                player.userData.rightHand.getWorldPosition(handPos);
                ball.position.copy(handPos);
                ball.rotation.set(0, 0, 0); // Stop spin when held
                return;
            }

            const wave = Math.sin(gameClock * DRIBBLE_RATE);
            const dribbleOffset = (wave < 0 ? 0 : wave) * 0.5; // Only raise/lower when in air
            const dribblePos = player.position.clone();
            
            dribblePos.y = GROUND_Y + BALL_RADIUS + DRIBBLE_HEIGHT + dribbleOffset;
            dribblePos.x += Math.sin(player.rotation.y) * 0.5; // Slight offset from player center
            dribblePos.z += Math.cos(player.rotation.y) * 0.5;

            // Simple "bounce" on the ground (lower limit)
            if (wave < -0.95) {
                // Simulate ground collision
                ballAngularVelocity.y = (Math.random() - 0.5) * 5; 
            }

            ball.position.copy(dribblePos);
            ball.rotation.x += ballAngularVelocity.x * TIME_STEP;
            ball.rotation.y += ballAngularVelocity.y * TIME_STEP;
        }

        function updatePlayerAnimation() {
            gameClock += TIME_STEP;

            // Player Jump/Vertical Movement
            if (player.position.y > GROUND_Y || player.userData.verticalVelocity !== 0) {
                player.userData.verticalVelocity += GRAVITY.y * TIME_STEP;
                player.position.y += player.userData.verticalVelocity * TIME_STEP;

                if (player.position.y <= GROUND_Y) {
                    player.position.y = GROUND_Y;
                    player.userData.verticalVelocity = 0;
                    isJumping = false;
                }
            }

            const rightArm = player.userData.rightArmGroup;
            const leftArm = player.userData.leftArmGroup;
            
            let swing = 0;
            if (isMoving && !isCharging && !isShooting) {
                // Walking animation
                swing = Math.sin(gameClock * WALK_BOB_SPEED) * ARM_SWING_ANGLE;
            } else if (isCharging) {
                // Charging shot animation (Arms up and forward)
                const chargeTime = (Date.now() - chargeStartTime) / 1000;
                const chargeProgress = Math.min(chargeTime / MAX_CHARGE_TIME_JUMPSHOT, 1);
                const chargeAngle = Math.PI * 0.4 * chargeProgress; 
                swing = -Math.PI / 2 + chargeAngle; 
            } else if (isShooting) {
                // Follow-through (Keep arms up for a moment)
                swing = -Math.PI / 4; 
            } else {
                // Idle or Post-shot animation (Arms down, relaxed)
                swing = Math.PI * 0.05; // Slightly forward/down
            }

            // Arms swing forward/backward on Z-axis
            rightArm.rotation.z = -swing; // Adjusted for the group's coordinate system
            leftArm.rotation.z = swing;

            // Leg swing (sync with walk bob)
            if (isMoving) {
                player.userData.legGroups[0].rotation.z = Math.sin(gameClock * WALK_BOB_SPEED) * ARM_SWING_ANGLE * 0.5;
                player.userData.legGroups[1].rotation.z = -Math.sin(gameClock * WALK_BOB_SPEED) * ARM_SWING_ANGLE * 0.5;
            } else {
                player.userData.legGroups[0].rotation.z *= 0.8;
                player.userData.legGroups[1].rotation.z *= 0.8;
            }
        }
        
        function updateAICheck() {
            // Simplified AI: Move toward the hoop when the ball is far, or toward the player when close
            if (opponent.position.distanceTo(player.position) > AI_PLAYER_FOLLOW_DIST) {
                // Retreat to defense position
                opponent.position.z += (AI_DEFENSE_Z - opponent.position.z) * AI_SPEED * 0.1;
                opponent.position.x += (0 - opponent.position.x) * AI_SPEED * 0.1;
            } else {
                // Follow the player
                const dir = player.position.clone().sub(opponent.position).setY(0).normalize();
                opponent.position.add(dir.multiplyScalar(AI_SPEED));
            }

            // Ensure opponent stays in bounds and doesn't pass the player on Z
            opponent.position.z = Math.max(opponent.position.z, RIM_Z_POS + 1); 
            opponent.position.z = Math.min(opponent.position.z, player.position.z - 0.5); 
            
            opponent.rotation.y = Math.atan2(player.position.x - opponent.position.x, player.position.z - opponent.position.z);
        }

        function updateChargeMeter() {
            if (!isCharging) return;

            const timeElapsed = (Date.now() - chargeStartTime) / 1000;
            const maxCharge = player.userData.isLayup ? MAX_CHARGE_TIME_LAYUP : MAX_CHARGE_TIME_JUMPSHOT;
            
            let power = timeElapsed / maxCharge;
            if (power > 1.0) {
                power = 1.0;
            }
            
            const meterBar = player.userData.isLayup ? 
                document.getElementById('layup-bar') : 
                document.getElementById('jumpshot-bar');
                
            if (player.userData.isLayup) {
                meterBar.style.height = `${power * 100}%`;
            } else {
                meterBar.style.width = `${power * 100}%`;
            }
            
            return power;
        }


        // --- Event Handlers (Moved into startGame) ---

        function onKeyDown(event) {
            if (event.key in keysPressed) {
                keysPressed[event.key] = true;
            }

            if (event.key === 'e' && !isShooting && !isCharging) {
                isCharging = true;
                chargeStartTime = Date.now();
                player.userData.isLayup = isInThePaint();

                const meterContainer = player.userData.isLayup ? 
                    document.getElementById('layup-meter-container') : 
                    document.getElementById('jumpshot-meter-container');
                meterContainer.style.display = 'block';
                
                // Also hide the other meter just in case
                if (player.userData.isLayup) {
                    document.getElementById('jumpshot-meter-container').style.display = 'none';
                } else {
                    document.getElementById('layup-meter-container').style.display = 'none';
                }

                // Initial jump for jumpshot
                if (!player.userData.isLayup && !isJumping) {
                    player.userData.verticalVelocity = JUMP_VELOCITY;
                    isJumping = true;
                }
            }

            if (event.key === 'c' && !isShooting) {
                const now = Date.now();
                if (now - lastCKeyPressTime > 200) { // Debounce
                    currentCameraView = (currentCameraView === 'player' ? 'goal' : 'player');
                    lastCKeyPressTime = now;
                }
            }
        }

        function onKeyUp(event) {
            if (event.key in keysPressed) {
                keysPressed[event.key] = false;
            }

            if (event.key === 'e' && isCharging) {
                isCharging = false;
                const releasePower = updateChargeMeter(); // Get final power
                
                if (player.userData.isLayup) {
                    launchLayup(releasePower);
                    document.getElementById('layup-meter-container').style.display = 'none';
                } else {
                    launchJumpshot(releasePower);
                    document.getElementById('jumpshot-meter-container').style.display = 'none';
                }
            }
        }

        function updateCamera() {
            if (currentCameraView === 'player') {
                const offset = new THREE.Vector3(0, 3, 5); 
                const rotation = player.rotation.y + Math.PI; 
                
                // Position the camera behind the player
                camera.position.x = player.position.x + Math.sin(rotation) * offset.z;
                camera.position.z = player.position.z + Math.cos(rotation) * offset.z;
                camera.position.y = player.position.y + offset.y;
                
                // Look at the player's head height
                const target = player.position.clone();
                target.y += 1.5;
                camera.lookAt(target);

            } else if (currentCameraView === 'goal') {
                // Fixed view from the side of the court, looking at the hoop
                camera.position.set(FENCE_X, 4, 0); 
                camera.lookAt(RIM_CENTER);
            }
        }

        // --- Main Game Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (!gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            updateChargeMeter();
            updatePlayerMovement();
            updateAICheck();
            updateBallPhysics();
            updateDribbleAnimation();
            updatePlayerAnimation();
            updateCamera();
            
            renderer.render(scene, camera);
        }

        // --- Initialization and Start Game Function (NEW) ---

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            
            // 1. Hide the start screen
            document.getElementById('start-screen').style.display = 'none';
            
            // 2. Show the game UI
            document.getElementById('ui-overlay').style.display = 'flex';
            document.getElementById('instructions').style.display = 'block';

            // 3. Enable controls
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            // 4. Start the main animation loop
            animate();
        }

        function init() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            createCourt();
            createHoop();
            createPlayer();
            createBall();
            createOpponent();

            // Initial camera setup before game start
            currentCameraView = 'player';
            updateCamera();

            window.addEventListener('resize', onWindowResize, false);
            
            // Add event listener for the Play button
            document.getElementById('play-button').addEventListener('click', startGame, false);
            
            // Render one frame with the start screen visible
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
