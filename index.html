<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D City: Clique Wars</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 5px; border: 2px solid #444; }
        #clique-selector { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 20px; text-align: center; color: white; border: 4px solid #fff; }
        .btn { padding: 10px 20px; margin: 10px; cursor: pointer; border: none; font-weight: bold; }
        #map-overlay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 300px; background: rgba(30,30,30,0.9); border: 2px solid #fff; }
        .dot { width: 10px; height: 10px; position: absolute; border-radius: 50%; transform: translate(-50%, -50%); border: 1px solid white; }
    </style>
</head>
<body>

<div id="clique-selector">
    <h2>CHOOSE YOUR CLIQUE</h2>
    <button class="btn" style="background: #2ecc71;" onclick="chooseClique('Green')">GREEN FAMILIES</button>
    <button class="btn" style="background: #9b59b6;" onclick="chooseClique('Purple')">PURPLE BALLERS</button>
</div>

<div id="ui" style="display:none;">
    <b id="clique-name">CLIQUE: NONE</b><br>
    TERRITORY: <span id="territory-owner">NEUTRAL</span><br>
    <small>E: Enter/Exit Car | WASD: Move</small>
</div>

<div id="map-overlay"><div id="player-dot" class="dot"></div></div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let myClique = null;
    let territoryOwner = 'Neutral';
    let gameState = { mode: 'ON_FOOT', activeVehicle: null };
    const keys = {};
    const collidables = [];
    const cars = [];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(10, 20, 10);
    scene.add(sun);

    // --- ARENA & TERRITORY ---
    const arenaPlatform = new THREE.Mesh(
        new THREE.CircleGeometry(25, 32),
        new THREE.MeshStandardMaterial({ color: 0x444444 })
    );
    arenaPlatform.rotation.x = -Math.PI/2;
    arenaPlatform.position.y = 0.1;
    scene.add(arenaPlatform);

    const arenaCenter = new THREE.Mesh(
        new THREE.CylinderGeometry(10, 12, 8, 16),
        new THREE.MeshStandardMaterial({ color: 0x888888 })
    );
    arenaCenter.position.y = 4;
    scene.add(arenaCenter);
    collidables.push(arenaCenter);

    // --- BUILDINGS & STREETS ---
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({color: 0x222222}));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // Create a few drivable cars
    function spawnCar(x, z) {
        const car = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 5), new THREE.MeshStandardMaterial({color: 0xff0000}));
        body.position.y = 1;
        car.add(body);
        car.position.set(x, 0, z);
        car.userData = { speed: 0, accel: 0.01, friction: 0.96, steer: 0.03 };
        scene.add(car);
        cars.push(car);
    }
    spawnCar(15, 15);
    spawnCar(-15, 25);

    // --- PLAYER ---
    const player = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), new THREE.MeshStandardMaterial({color: 0xffffff}));
    player.position.set(0, 1, 40);
    scene.add(player);

    // --- LOGIC ---
    window.chooseClique = (c) => {
        myClique = c;
        document.getElementById('clique-selector').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('clique-name').innerText = "CLIQUE: " + c;
        document.getElementById('clique-name').style.color = (c === 'Green') ? '#2ecc71' : '#9b59b6';
        player.material.color.set(c === 'Green' ? 0x2ecc71 : 0x9b59b6);
    };

    window.onkeydown = (e) => { 
        keys[e.code] = true; 
        if(e.code === 'KeyE') handleVehicleSwap();
        if(e.code === 'KeyM') toggleMap();
    };
    window.onkeyup = (e) => keys[e.code] = false;

    function handleVehicleSwap() {
        if(gameState.mode === 'ON_FOOT') {
            cars.forEach(car => {
                if(player.position.distanceTo(car.position) < 6) {
                    gameState.mode = 'DRIVING';
                    gameState.activeVehicle = car;
                    player.visible = false;
                }
            });
        } else {
            player.position.set(gameState.activeVehicle.position.x + 4, 1, gameState.activeVehicle.position.z);
            player.visible = true;
            gameState.mode = 'ON_FOOT';
            gameState.activeVehicle = null;
        }
    }

    function update() {
        if(!myClique) return;

        // Walking
        if(gameState.mode === 'ON_FOOT') {
            const speed = 0.3;
            if(keys['KeyW']) player.position.z -= speed;
            if(keys['KeyS']) player.position.z += speed;
            if(keys['KeyA']) player.position.x -= speed;
            if(keys['KeyD']) player.position.x += speed;
        } 
        // Driving
        else {
            const v = gameState.activeVehicle;
            const stats = v.userData;
            if(keys['KeyW']) stats.speed += stats.accel;
            if(keys['KeyS']) stats.speed -= stats.accel;
            stats.speed *= stats.friction;
            
            if(Math.abs(stats.speed) > 0.01) {
                if(keys['KeyA']) v.rotation.y += stats.steer;
                if(keys['KeyD']) v.rotation.y -= stats.steer;
            }
            v.position.x += Math.sin(v.rotation.y) * stats.speed;
            v.position.z += Math.cos(v.rotation.y) * stats.speed;
            player.position.copy(v.position);
        }

        // Camera
        camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 20, player.position.z + 30), 0.1);
        camera.lookAt(player.position);

        // Capture Territory Logic
        const distToCenter = player.position.distanceTo(new THREE.Vector3(0,0,0));
        if(distToCenter < 25) {
            territoryOwner = myClique;
            arenaPlatform.material.color.set(myClique === 'Green' ? 0x2ecc71 : 0x9b59b6);
            document.getElementById('territory-owner').innerText = myClique.toUpperCase();
        }

        // Update Map
        document.getElementById('player-dot').style.left = (player.position.x + 150) + 'px';
        document.getElementById('player-dot').style.top = (player.position.z + 150) + 'px';
        document.getElementById('player-dot').style.background = (myClique === 'Green' ? '#2ecc71' : '#9b59b6');
    }

    function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
    }
    animate();

    function toggleMap() {
        const m = document.getElementById('map-overlay');
        m.style.display = m.style.display === 'block' ? 'none' : 'block';
    }
</script>
</body>
</html>
