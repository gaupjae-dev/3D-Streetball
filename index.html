<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Underground 3D: The Pit (Enhanced)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #0f0; 
            background: rgba(0,0,0,0.9); padding: 20px; border-left: 5px solid #00aaff;
            pointer-events: none; z-index: 10; width: 280px;
        }
        #arena-ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: none; color: #ff0000; font-size: 32px; font-weight: bold;
            text-shadow: 0 0 10px #000; z-index: 20;
        }
        .hp-bar { width: 100%; height: 10px; background: #300; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #f00; transition: 0.1s; }
        .btn-group { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 20; }
        button { background: #222; color: #fff; border: 1px solid #444; padding: 10px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 20px; font-weight: bold;">SYNDICATE</div>
        <div id="rep-display" style="color: #00aaff;">REP: 0</div>
        <div class="hp-bar"><div id="hp-fill"></div></div>
        <div id="status-text" style="color: #0ff; font-size: 12px; margin-top: 5px;">ON FOOT</div>
        <div style="font-size: 10px; color: #555; margin-top: 10px;">WASD to move | SPACE to punch | E/F to enter/exit car</div>
    </div>

    <div id="arena-ui">ARENA DUEL: ACTIVE</div>

    <div class="btn-group">
        <button id="pauseBtn">PAUSE</button>
        <button id="mapBtn">MAP</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.Fog(0x020205, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const clock = new THREE.Clock();
        const amb = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(amb);

        // --- Game State ---
        let hp = 100, rep = 0, paused = false, mapMode = false, inVehicle = false, shake = 0;
        const keys = {}, buildings = [], enemies = [];
        let vehicleVel = 0, vehicleRot = 0;

        // --- Environment ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Box Collisions Setup
        function checkCollision(obj, meshArray, padding = 0.5) {
            const box = new THREE.Box3().setFromObject(obj);
            for (let mesh of meshArray) {
                const otherBox = new THREE.Box3().setFromObject(mesh);
                if (box.intersectsBox(otherBox)) return true;
            }
            return false;
        }

        // The Boxing Ring
        const ring = new THREE.Group();
        const ringFloor = new THREE.Mesh(new THREE.BoxGeometry(12, 0.5, 12), new THREE.MeshStandardMaterial({ color: 0x660000 }));
        ring.add(ringFloor);
        ring.position.set(-60, 0, 0);
        scene.add(ring);

        // Buildings
        function makeB(x, z, h, w, col) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: col }));
            b.position.set(x, h/2, z);
            scene.add(b);
            buildings.push(b);
        }
        
        makeB(20, -20, 8, 15, 0x222222); // Garage
        for(let i=0; i<25; i++) {
            makeB(Math.random()*150-75, Math.random()*150-75, Math.random()*30+10, 8, 0x0a0a15);
        }

        // --- Vehicle ---
        const vehicle = new THREE.Group();
        const vBody = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 5), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
        vBody.position.y = 0.7;
        vehicle.add(vBody);
        
        // Headlights
        const headlight = new THREE.SpotLight(0xffffff, 50, 40, 0.5);
        headlight.position.set(0, 1, -2.5);
        headlight.target.position.set(0, 0, -10);
        vehicle.add(headlight);
        vehicle.add(headlight.target);

        vehicle.position.set(20, 0, -10);
        scene.add(vehicle);

        // --- Player ---
        const player = new THREE.Group();
        const pMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x00aaff }));
        pMesh.position.y = 1;
        player.add(pMesh);
        scene.add(player);
        player.position.set(0, 0, 10);

        function spawnEnemy(x, z, size=1, isBoss=false) {
            const group = new THREE.Group();
            const e = new THREE.Mesh(new THREE.BoxGeometry(size, 2*size, size), new THREE.MeshStandardMaterial({ color: isBoss?0xffaa00:0xff3333 }));
            e.position.y = size;
            group.add(e);

            // Health Bar Mini
            const hpGeo = new THREE.PlaneGeometry(2, 0.2);
            const hpMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const hpMesh = new THREE.Mesh(hpGeo, hpMat);
            hpMesh.position.y = size * 2.5;
            group.add(hpMesh);

            group.position.set(x, 0, z);
            group.userData = { hp: isBoss?300:50, maxHp: isBoss?300:50, isBoss, hpBar: hpMesh };
            scene.add(group);
            enemies.push(group);
        }

        spawnEnemy(-10, -10); spawnEnemy(10, 10);

        // --- Logic ---
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        document.getElementById('pauseBtn').onclick = () => paused = !paused;
        document.getElementById('mapBtn').onclick = () => mapMode = !mapMode;

        function update() {
            if (paused) return;
            const delta = clock.getDelta();
            const activeObj = inVehicle ? vehicle : player;

            if (!inVehicle) {
                // Foot Controls
                const moveS = 15 * delta;
                const oldPos = player.position.clone();
                
                if (keys['w']) player.position.z -= moveS;
                if (keys['s']) player.position.z += moveS;
                if (keys['a']) player.position.x -= moveS;
                if (keys['d']) player.position.x += moveS;

                if (checkCollision(player, buildings)) player.position.copy(oldPos);

                // Enter Car
                if (keys['e'] && player.position.distanceTo(vehicle.position) < 5) {
                    inVehicle = true; player.visible = false;
                    document.getElementById('status-text').innerText = "DRIVING";
                }

                // Punching logic
                if (keys[' ']) {
                    pMesh.scale.set(1.5, 0.8, 1.5);
                    enemies.forEach((en, i) => {
                        if (player.position.distanceTo(en.position) < 4) {
                            en.userData.hp -= 40 * delta;
                            shake = 0.1;
                        }
                    });
                } else pMesh.scale.set(1, 1, 1);

                // Arena Trigger
                if (player.position.distanceTo(ring.position) < 6) {
                    document.getElementById('arena-ui').style.display = 'block';
                    if (!enemies.some(e => e.userData.isBoss)) spawnEnemy(-60, 0, 2, true);
                } else document.getElementById('arena-ui').style.display = 'none';

            } else {
                // Car Controls
                const oldCarPos = vehicle.position.clone();
                if (keys['w']) vehicleVel += 30 * delta;
                if (keys['s']) vehicleVel -= 15 * delta;
                vehicleVel *= 0.98; // Friction

                if (Math.abs(vehicleVel) > 0.1) {
                    if (keys['a']) vehicleRot += 2 * delta;
                    if (keys['d']) vehicleRot -= 2 * delta;
                }
                vehicle.rotation.y = vehicleRot;
                vehicle.translateZ(-vehicleVel * delta);

                if (checkCollision(vehicle, buildings)) {
                    vehicle.position.copy(oldCarPos);
                    vehicleVel *= -0.5; // Bounce
                }

                // Hit and Run
                enemies.forEach((en) => {
                    if (vehicle.position.distanceTo(en.position) < 4 && Math.abs(vehicleVel) > 5) {
                        en.userData.hp -= Math.abs(vehicleVel) * 0.5;
                        en.position.addScaledVector(new THREE.Vector3().subVectors(en.position, vehicle.position).normalize(), 2);
                        shake = 0.4;
                    }
                });

                if (keys['f']) { inVehicle = false; player.visible = true; player.position.copy(vehicle.position).x += 4; }
            }

            // Enemy AI & Clean up
            enemies.forEach((en, i) => {
                const dist = en.position.distanceTo(player.position);
                // Health Bar scaling
                en.userData.hpBar.scale.x = Math.max(0, en.userData.hp / en.userData.maxHp);
                en.userData.hpBar.lookAt(camera.position);

                if (en.userData.hp <= 0) {
                    scene.remove(en);
                    enemies.splice(i, 1);
                    rep += en.userData.isBoss ? 500 : 50;
                    return;
                }

                if (dist < 20 && !inVehicle) {
                    const speed = en.userData.isBoss ? 4 : 2.5;
                    en.position.addScaledVector(new THREE.Vector3().subVectors(player.position, en.position).normalize(), speed * delta);
                    if (dist < 2) hp -= (en.userData.isBoss ? 30 : 10) * delta;
                }
            });

            // Camera System
            const targetPos = activeObj.position.clone();
            if (mapMode) {
                camera.position.lerp(new THREE.Vector3(targetPos.x, 100, targetPos.z + 1), 0.1);
            } else {
                const offset = inVehicle ? new THREE.Vector3(0, 15, 25) : new THREE.Vector3(0, 10, 15);
                camera.position.lerp(targetPos.add(offset), 0.1);
            }
            if (shake > 0) { camera.position.x += (Math.random()-0.5) * shake; shake *= 0.9; }
            camera.lookAt(activeObj.position);

            // UI
            document.getElementById('hp-fill').style.width = hp + "%";
            document.getElementById('rep-display').innerText = "REP: " + Math.floor(rep);
            if (hp <= 0) { alert("WASTED - Final Rep: " + rep); location.reload(); }
        }

        function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
