<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Streetball Shooter - Physics Refined</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 80vh;
            max-height: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            background-color: #2e2e4f;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            color: #ffffff;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        #score, #message {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 0.9rem;
            text-align: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 10;
        }
        #instructions strong {
            color: #00ffaa;
            text-shadow: 0 0 5px #00ffaa;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* --- JUMPSHOT METER (Horizontal) --- */
        #jumpshot-meter-container {
            position: absolute;
            bottom: 50px; 
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #jumpshot-bar {
            height: 100%;
            width: 0%;
            /* Gradient: Red -> Yellow -> Green (perfect) -> Yellow -> Red */
            background: linear-gradient(90deg, 
                rgba(255, 0, 0, 0.9), 
                rgba(255, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 50%, 
                rgba(255, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: width 0.01s linear;
        }
        #jumpshot-target {
            position: absolute;
            top: 0;
            left: 45%; 
            width: 10%;
            height: 100%;
            border-left: 2px solid rgba(0, 0, 0, 0.8);
            border-right: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            transition: left 0.1s ease-out, width 0.1s ease-out; 
        }

        /* --- LAYUP METER (Vertical) --- */
        #layup-meter-container {
            position: absolute;
            /* Positioning: near player hand, offset from the bottom right */
            bottom: 100px; 
            right: 50px; 
            width: 20px;
            height: 150px; 
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #00ffaa;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #layup-bar {
            width: 100%;
            height: 0%;
            position: absolute; 
            bottom: 0;
            /* Vertical Gradient: Bottom (Red) -> Middle (Green) -> Top (Red) */
            background: linear-gradient(to top, 
                rgba(255, 0, 0, 0.9) 0%,
                rgba(0, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: height 0.01s linear;
        }
        #layup-target {
            position: absolute;
            bottom: 40%; /* 40% to 60% is the perfect zone (20% total) */
            left: 0; 
            width: 100%;
            height: 20%; /* Wider perfect window */
            border-top: 2px solid rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score">Score: 0</div>
            <div id="message">Streetball Ready!</div>
        </div>
        <div id="instructions">
            Use W, A, S, D to move. **HOLD E** to **JUMPSHOT (outside paint)** or **LAYUP (inside paint)**. 
            Press **C** to toggle **Goal View**!
        </div>
        
        <div id="jumpshot-meter-container">
            <div id="jumpshot-bar"></div>
            <div id="jumpshot-target"></div>
        </div>
        
        <div id="layup-meter-container">
            <div id="layup-bar"></div>
            <div id="layup-target"></div>
        </div>
    </div>

    <script type="module">
        // --- Global Variables and Constants ---
        let scene, camera, renderer;
        let ball, hoop, court, player, opponent;
        let score = 0;
        let isShooting = false;
        let ballVelocity = new THREE.Vector3();
        let ballAngularVelocity = new THREE.Vector3(0, 0, 0); 
        const GRAVITY = new THREE.Vector3(0, -9.8, 0); 
        const TIME_STEP = 1/60; 
        const FENCES = []; 

        // Shot Meter State
        let isCharging = false;
        let chargeStartTime = 0;
        
        // Jumpshot Constants
        const MAX_CHARGE_TIME_JUMPSHOT = 1.5; 
        const PERFECT_WINDOW_JUMPSHOT_MIN = 0.45;
        const PERFECT_WINDOW_JUMPSHOT_MAX = 0.55;
        
        // Layup Constants
        const MAX_CHARGE_TIME_LAYUP = 0.5; // Much shorter charge time
        const PERFECT_WINDOW_LAYUP_MIN = 0.40; // Wider window (40% to 60%)
        const PERFECT_WINDOW_LAYUP_MAX = 0.60;

        let isGuaranteedShot = false; 
        let shotProgress = 0;
        let shotStartPos = new THREE.Vector3();
        const shotTargetPos = new THREE.Vector3(0, 3.05, -8); 
        let shotDuration = 0; 
        
        // Player State
        const JUMP_VELOCITY = 6; 
        const JUMPSHOT_HEIGHT = 1.0; 
        let isJumping = false;
        const GROUND_Y = -0.24; 
        const LAYUP_AREA_Z = 5.8; // Z-limit for the key 
        const LAYUP_AREA_X = 2.5; // X-limit for the key
        
        // Movement and Dribbling
        const PLAYER_SPEED = 0.15; 
        const DRIBBLE_HEIGHT = 0.6; 
        const DRIBBLE_RATE = 10; 
        let keysPressed = { w: false, a: false, s: false, d: false, e: false, c: false }; 
        let gameClock = 0;

        // NEW Animation States
        let isMoving = false; // Tracks if WASD keys are active
        let isIdle = false; // True when stationary AND not charging/shooting
        const WALK_BOB_SPEED = 15;
        const ARM_SWING_ANGLE = 0.5; // Max angle for arm swing in radians

        // Hoop and Ball constants
        const BALL_RADIUS = 0.24;
        const RIM_RADIUS = 0.228;
        const RIM_THICKNESS = 0.02;
        const RIM_Y_POS = 3.05; 
        const RIM_Z_POS = -8; 
        const RIM_CENTER = new THREE.Vector3(0, RIM_Y_POS, RIM_Z_POS);
        const BOUNCE_DAMPING = 0.6; 
        const RIM_DAMPING = 0.8; 

        // Court Boundaries 
        const FENCE_X = 15;
        const FENCE_Z = 20;
        
        // AI Defender Constants (simplified)
        const AI_SPEED = 0.1;
        const AI_DEFENSE_Z = -5;  
        const AI_PLAYER_FOLLOW_DIST = 15; 
        const AI_BLOCK_RADIUS = 2; 

        // Camera State
        let currentCameraView = 'player'; 
        let lastCKeyPressTime = 0;

        // --- Utility Functions ---

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            updateMessage(`SWISH! +${points} points!`);
        }

        function isInThePaint() {
            const pos = player.position;
            const zDistanceFromHoop = pos.z - RIM_Z_POS;
            return zDistanceFromHoop < LAYUP_AREA_Z && Math.abs(pos.x) < LAYUP_AREA_X;
        }

        function createFences() {
            const FENCE_THICKNESS = 0.1;
            const FENCE_HEIGHT = 5;
            const lineY = -BALL_RADIUS + 0.005; 
            const wallY = lineY + FENCE_HEIGHT / 2;
            const fenceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a4a4a, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            // Side Walls
            const sideWallGeo = new THREE.BoxGeometry(FENCE_THICKNESS, FENCE_HEIGHT, 40);
            const leftFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            leftFence.position.set(-FENCE_X, wallY, 0);
            leftFence.userData.type = 'vertical';
            leftFence.userData.axis = 'x';
            leftFence.userData.pos = -FENCE_X;
            scene.add(leftFence);
            FENCES.push(leftFence);

            const rightFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            rightFence.position.set(FENCE_X, wallY, 0);
            rightFence.userData.type = 'vertical';
            rightFence.userData.axis = 'x';
            rightFence.userData.pos = FENCE_X;
            scene.add(rightFence);
            FENCES.push(rightFence);

            // Base Walls
            const baseWallGeo = new THREE.BoxGeometry(30.1 + FENCE_THICKNESS, FENCE_HEIGHT, FENCE_THICKNESS); 
            const backFence = new THREE.Mesh(baseWallGeo, fenceMaterial);
            backFence.position.set(0, wallY, -FENCE_Z);
            backFence.userData.type = 'vertical';
            backFence.userData.axis = 'z';
            backFence.userData.pos = -FENCE_Z;
            scene.add(backFence);
            FENCES.push(backFence);
            
            const frontFence = new THREE.Mesh(baseWallGeo, fenceMaterial); 
            frontFence.position.set(0, wallY, FENCE_Z);
            frontFence.userData.type = 'vertical';
            frontFence.userData.axis = 'z';
            frontFence.userData.pos = FENCE_Z;
            scene.add(frontFence);
            FENCES.push(frontFence);
        }

        function createCourt() {
            const groundGeometry = new THREE.PlaneGeometry(30, 40);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            court = new THREE.Mesh(groundGeometry, groundMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -BALL_RADIUS; 
            court.receiveShadow = true; 
            scene.add(court);

            createFences(); 

            // Court Lines (Simplified for brevity, same as original logic)
            const LINE_WIDTH = 0.1;
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineY = -BALL_RADIUS + 0.005;

            const PERIMETER_X = 14.95;
            const PERIMETER_Z = 19.95;
            const lineGeoX = new THREE.BoxGeometry(LINE_WIDTH, 0.01, 40); 
            const lineGeoZ = new THREE.BoxGeometry(30, 0.01, LINE_WIDTH);

            const leftSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            leftSideLine.position.set(-PERIMETER_X, lineY, 0);
            scene.add(leftSideLine);

            const rightSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            rightSideLine.position.set(PERIMETER_X, lineY, 0);
            scene.add(rightSideLine);

            const frontBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            frontBaseLine.position.set(0, lineY, PERIMETER_Z);
            scene.add(frontBaseLine);

            const backBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            backBaseLine.position.set(0, lineY, -PERIMETER_Z);
            scene.add(backBaseLine);


            const KEY_WIDTH = 4.9; 
            const KEY_LENGTH = LAYUP_AREA_Z + (PERIMETER_Z - Math.abs(RIM_Z_POS)); 

            const keySideGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, KEY_LENGTH);
            const keySideZ = RIM_Z_POS + KEY_LENGTH / 2;

            const leftKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            leftKeyLine.position.set(-KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(leftKeyLine);

            const rightKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            rightKeyLine.position.set(KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(rightKeyLine);

            const freeThrowLineGeo = new THREE.BoxGeometry(KEY_WIDTH + LINE_WIDTH, 0.01, LINE_WIDTH);
            const freeThrowLineZ = RIM_Z_POS + LAYUP_AREA_Z; 

            const freeThrowLine = new THREE.Mesh(freeThrowLineGeo, lineMaterial);
            freeThrowLine.position.set(0, lineY, freeThrowLineZ);
            scene.add(freeThrowLine);

            const FT_RADIUS = 1.8; 
            const ftCircleShape = new THREE.Shape();
            ftCircleShape.absarc(0, freeThrowLineZ, FT_RADIUS, 0, Math.PI * 2, true);
            const ftCirclePoints = ftCircleShape.getPoints(50);
            const ftCircleGeometry = new THREE.BufferGeometry().setFromPoints(ftCirclePoints);
            const ftCircleMesh = new THREE.Line(ftCircleGeometry, lineMaterial);
            ftCircleMesh.position.y = lineY;
            ftCircleMesh.rotation.x = Math.PI / 2;
            scene.add(ftCircleMesh);

            const threePtRadius = 6.75;
            const arcShape = new THREE.Shape();
            arcShape.absarc(0, RIM_Z_POS, threePtRadius, Math.PI * 0.35, Math.PI * 0.65, true); 
            const arcPoints = arcShape.getPoints(50); 
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMesh = new THREE.Line(arcGeometry, lineMaterial);
            arcMesh.position.y = lineY;
            arcMesh.rotation.x = Math.PI / 2;
            scene.add(arcMesh);

            const wingZStart = RIM_Z_POS + Math.cos(Math.PI * 0.35) * threePtRadius;
            const wingLineLength = PERIMETER_Z - wingZStart; 
            const wingGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, wingLineLength);
            
            const wingX = Math.sin(Math.PI * 0.35) * threePtRadius; 

            const leftWing = new THREE.Mesh(wingGeo, lineMaterial);
            leftWing.position.set(-wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, lineMaterial);
            rightWing.position.set(wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(rightWing);
        }

        function createHoop() {
            hoop = new THREE.Group();

            // Dimensions
            const BACKBOARD_WIDTH = 1.83; 
            const BACKBOARD_HEIGHT = 1.07; 
            const BACKBOARD_THICKNESS = 0.03;
            const RIM_THICKNESS_VISUAL = 0.02; 
            const POLE_OFFSET_Z = 1.2; 

            // Backboard
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8
            });
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_Y_POS + BACKBOARD_HEIGHT / 2 - 0.1, RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2);
            backboard.castShadow = true;
            backboard.receiveShadow = true;
            hoop.add(backboard);
            // Add Backboard info to user data for physics
            backboard.userData.isBackboard = true;
            hoop.userData.BACKBOARD_X_HALF = BACKBOARD_WIDTH / 2;
            hoop.userData.BACKBOARD_Y_MIN = RIM_Y_POS - 0.1;
            hoop.userData.BACKBOARD_Y_MAX = RIM_Y_POS + BACKBOARD_HEIGHT - 0.1;
            hoop.userData.BACKBOARD_Z_POS = RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2;
            hoop.userData.backboardMesh = backboard;


            // Rim (Visual)
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_THICKNESS_VISUAL / 2, 16, 50);
            const rimMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_Y_POS, RIM_Z_POS);
            rim.castShadow = true;
            hoop.add(rim);

            // Net
            const NET_HEIGHT = 0.45; 
            const NET_BOTTOM_RADIUS = 0.1;
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, NET_BOTTOM_RADIUS, NET_HEIGHT, 32, 1, true);
            const netMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, RIM_Y_POS - NET_HEIGHT / 2, RIM_Z_POS);
            hoop.add(net);
            
            // Pole
            const poleHeight = RIM_Y_POS + BACKBOARD_HEIGHT + 1.0; 
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, poleHeight, 16);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, poleHeight / 2 - BALL_RADIUS, RIM_Z_POS - POLE_OFFSET_Z);
            pole.castShadow = true;
            hoop.add(pole);
            
            hoop.position.set(0, 0, 0); 
            scene.add(hoop);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            // Loaded a simple texture to help visualize spin
            const ballTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/uv_grid_opengl.jpg'); 
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xff8c00, specular: 0x222222, shininess: 30, map: ballTexture
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            scene.add(ball);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            const headRadius = 0.2;
            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const limbWidth = 0.1;
            const legHeight = 0.9;
            const armLength = 0.6; 
            
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00aaff }); 
            const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac }); 
            const shortsMaterial = new THREE.MeshLambertMaterial({ color: 0x0088cc }); 
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); 

            // Head
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = legHeight + torsoHeight - headRadius * 0.2; 
            playerGroup.add(head);

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16); 
            const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2; 
            playerGroup.add(torso);
            
            // Right Arm Group (Articulated)
            const upperArmLength = armLength * 0.5;
            const lowerArmLength = armLength * 0.5;
            const upperArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.8, limbWidth * 0.8, upperArmLength, 8);
            const lowerArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.7, limbWidth * 0.7, lowerArmLength, 8);
            const handGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); 

            const rightArmGroup = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.x = upperArmLength / 2; 
            rightUpperArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightUpperArm);
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            rightLowerArm.position.x = upperArmLength + lowerArmLength / 2; 
            rightLowerArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightLowerArm);
            const rightHand = new THREE.Mesh(handGeometry, skinMaterial); // Tagged Hand
            rightHand.position.x = upperArmLength + lowerArmLength + 0.05; 
            rightArmGroup.add(rightHand);
            rightArmGroup.position.set(torsoRadius, legHeight + torsoHeight * 0.7, 0); 
            playerGroup.add(rightArmGroup);

            // Left Arm Group
            const leftArmGroup = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.x = -(upperArmLength / 2); 
            leftUpperArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftUpperArm);
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            leftLowerArm.position.x = -(upperArmLength + lowerArmLength / 2); 
            leftLowerArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftLowerArm);
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.x = -(upperArmLength + lowerArmLength + 0.05);
            leftArmGroup.add(leftHand);
            leftArmGroup.position.set(-torsoRadius, legHeight + torsoHeight * 0.7, 0);
            playerGroup.add(leftArmGroup);

            // Legs and Shoes (Simple groups)
            const legGeometry = new THREE.CylinderGeometry(limbWidth, limbWidth, legHeight, 8);
            
            const rightLegGroup = new THREE.Group();
            const rightLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            rightLeg.position.y = legHeight / 2;
            rightLegGroup.add(rightLeg);
            rightLegGroup.position.set(torsoRadius * 0.4, 0, 0);
            playerGroup.add(rightLegGroup);
            
            const leftLegGroup = new THREE.Group();
            const leftLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            leftLeg.position.y = legHeight / 2;
            leftLegGroup.add(leftLeg);
            leftLegGroup.position.set(-torsoRadius * 0.4, 0, 0);
            playerGroup.add(leftLegGroup);
            
            const shoeGeometry = new THREE.BoxGeometry(limbWidth * 2, 0.15, limbWidth * 3);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(torsoRadius * 0.4, legHeight * 0.05, 0.1); 
            playerGroup.add(rightShoe);
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-torsoRadius * 0.4, legHeight * 0.05, 0.1);
            playerGroup.add(leftShoe);
            
            playerGroup.position.set(0, GROUND_Y, 6);
            player = playerGroup;
            player.castShadow = true; 
            player.rotation.y = Math.PI; 
            
            player.userData.rightArmGroup = rightArmGroup; 
            player.userData.leftArmGroup = leftArmGroup;
            player.userData.rightHand = rightHand;
            player.userData.legGroups = [rightLegGroup, leftLegGroup];
            player.userData.verticalVelocity = 0;
            player.userData.isLayup = false; 
            
            scene.add(player);
        }
        
        function createOpponent() {
            const oppGroup = new THREE.Group();
            const oppBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 }); 
            const oppSkinMaterial = new THREE.MeshLambertMaterial({ color: 0x6e4a2c }); 

            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const legHeight = 0.9;

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16);
            const torso = new THREE.Mesh(torsoGeometry, oppBodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2;
            oppGroup.add(torso);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, oppSkinMaterial);
            head.position.y = legHeight + torsoHeight + 0.18;
            oppGroup.add(head);

            // Legs (Simple)
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, legHeight, 8);
            const rightLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            rightLeg.position.set(torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(rightLeg);
            const leftLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            leftLeg.position.set(-torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(leftLeg);
            
            oppGroup.position.set(0, GROUND_Y, -5); 
            opponent = oppGroup;
            opponent.castShadow = true;
            opponent.userData.verticalVelocity = 0; 
            
            scene.add(opponent);
        }

        function resetBall() {
            ballVelocity.set(0, 0, 0);
            ballAngularVelocity.set(0, 0, 0);
            isShooting = false;
            isGuaranteedShot = false;
            player.userData.isLayup = false; // Reset layup state
            isJumping = false;
            player.userData.verticalVelocity = 0;
            player.position.y = GROUND_Y;
            
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            
            // Hide both meters on reset
            document.getElementById('jumpshot-meter-container').style.display = 'none';
            document.getElementById('layup-meter-container').style.display = 'none';
            
            updateMessage("Ready to shoot! Hold E to shoot.");
            
            // Explicitly call update to snap positions/animations on reset
            updateMovementAndDribble(); 
        }

        function launchLayup(power) {
            if (isShooting) return;

            // Check for AI influence (simple block)
            const aiDistSq = opponent.position.clone().setY(0).distanceToSq(player.position.clone().setY(0));
            const isBlocked = aiDistSq < AI_BLOCK_RADIUS * AI_BLOCK_RADIUS && opponent.position.z < player.position.z;

            // Base layup velocity
            let vx = 0;
            let vy = 12;
            let vz = 12;
            
            if (isGuaranteedShot) {
                // Perfect Layup (Green Window): Minimal error
                vz = 14; 
                vy = 13;
                vx = 0; 
                updateMessage("PERFECT LAYUP! SWISH!");
            } else {
                // Non-perfect Layup: High error and lower velocity based on 'power' 
                const idealPower = 0.5;
                const errorFactor = Math.abs(power - idealPower) * 5; 
                
                vz = 11 + (Math.random() - 0.5) * 4 * errorFactor; 
                vy = 11 + (Math.random() - 0.5) * 3 * errorFactor;
                vx = (Math.random() - 0.5) * 3 * errorFactor; 
                
                updateMessage("Layup Contested!");
            }
            
            // Apply AI block penalty
            if (isBlocked) {
                vy *= 0.7; 
                vz *= 0.8; 
                vx += (Math.random() > 0.5 ? 1 : -1) * 2; 
                updateMessage("BLOCKED! Heavy Contest!");
            }

            // Set launch position and velocity
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            
            ballVelocity.set(vx, vy, -vz); 
            // Layup usually has little backspin, just a slight rotation
            ballAngularVelocity.set((Math.random() - 0.5) * 5, 10, 0);
            
            isShooting = true;
            isJumping = false; 
            player.userData.verticalVelocity = 0; 
        }

        function launchJumpshot(power) {
            if (isShooting) return;

            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            
            isShooting = true;
            isJumping = false;
            player.userData.verticalVelocity = 0;

            if (isGuaranteedShot) {
                // Perfect shot takes the animation path
                shotProgress = 0;
                shotStartPos.copy(ball.position); 
                const distZ = Math.max(1, player.position.z - RIM_Z_POS);
                shotDuration = Math.min(2.0, 0.7 + distZ * 0.07); 
                // Add perfect backspin to guaranteed shot for visual
                ballAngularVelocity.set(-15, 0, 0); 
                updateMessage("PERFECT RELEASE! SWISH!"); // Message added here for consistency
                return;
            }

            // --- Standard Physics Launch for REALISTIC MISSES ---
            const VELOCITY_SCALE = Math.min(1.8, power); 
            const distZ = Math.max(1, player.position.z - RIM_Z_POS); 
            
            // Estimate base velocity needed to reach rim height and distance
            const base_vz = distZ * 0.85; 
            const base_vy = 13 + distZ * 0.5; 
            
            const vz = base_vz * VELOCITY_SCALE; 
            const vy = base_vy * VELOCITY_SCALE; 
            
            let dx = 0;
            const idealPower = 1.0;
            
            // Apply error based on release power
            if (power < idealPower - 0.3 || power > idealPower + 0.3) {
                const errorFactor = Math.abs(power - idealPower) * 2; 
                dx = (Math.random() - 0.5) * 1.5 * errorFactor; 
                updateMessage("Off Target!");
            } else {
                dx = (Math.random() - 0.5) * 0.2; 
                updateMessage("Good Release!");
            }

            ballVelocity.set(dx, vy, -vz);
            
            // Backspin (rotation on the X-axis) is crucial for a real shot
            const spinX = -(10 + distZ * 0.5); 
            ballAngularVelocity.set(spinX, 0, 0);
        }

        /**
         * Updates the player's pose based on game state (Charging, Jumpshot, Layup, Idle).
         */
        function updatePlayerAnimations() {
            const RIGHT_ARM = player.userData.rightArmGroup;
            const LEFT_ARM = player.userData.leftArmGroup;
            const LEG_GROUPS = player.userData.legGroups;
            
            const JUMP_UP_ANGLE = Math.PI * 1.3;
            const SHOT_CHARGE_ANGLE = Math.PI / 4;

            if (isCharging) {
                // --- 2. Transition/Crouch (Integrated into Charge) ---
                const maxCharge = player.userData.isLayup ? MAX_CHARGE_TIME_LAYUP : MAX_CHARGE_TIME_JUMPSHOT;
                const chargeRatio = Math.min(1, (performance.now() - chargeStartTime) / (maxCharge * 1000));
                
                // Crouch the player (makes them visibly 'bend their knees')
                const crouchY = GROUND_Y - 0.2 * chargeRatio;
                player.position.y += (crouchY - player.position.y) * 0.2; 

                // Bring arms up to chest
                const armAngle = Math.PI / 2 + SHOT_CHARGE_ANGLE * chargeRatio;
                RIGHT_ARM.rotation.x = armAngle;
                LEFT_ARM.rotation.x = armAngle;
                
                // Reset arm swing z rotation
                RIGHT_ARM.rotation.z *= 0.8;
                LEFT_ARM.rotation.z *= 0.8;

            } else if (isJumping) {
                // Jumpshot / Layup Jump
                
                // Animate jump height 
                const jumpProgress = (player.position.y - GROUND_Y) / (JUMPSHOT_HEIGHT);
                
                if (player.userData.isLayup) {
                    // Layup Jump extension
                    RIGHT_ARM.rotation.x = JUMP_UP_ANGLE + 0.2; 
                    LEFT_ARM.rotation.x = JUMP_UP_ANGLE * 0.8;
                } else {
                    // Jumpshot release follow through
                    const releaseProgress = Math.min(1, jumpProgress * 2);
                    RIGHT_ARM.rotation.x = JUMP_UP_ANGLE;
                    LEFT_ARM.rotation.x = JUMP_UP_ANGLE;
                }
                
            } else if (isShooting && isGuaranteedShot) {
                // Follow the smooth shot animation path
                
                // Arms remain extended after release
                RIGHT_ARM.rotation.x = JUMP_UP_ANGLE;
                LEFT_ARM.rotation.x = JUMP_UP_ANGLE;
                
            } else {
                // --- Dribbling/Idle Pose ---
                
                // Player vertical position snap back to ground
                player.position.y += (GROUND_Y - player.position.y) * 0.1;

                isMoving = keysPressed.w || keysPressed.a || keysPressed.d || keysPressed.s;
                isIdle = !isMoving && !isCharging && !isShooting && player.position.y <= GROUND_Y + 0.01;

                if (isMoving) {
                    // **1. Walk/Run Cycle**
                    const step = Math.sin(gameClock * WALK_BOB_SPEED);
                    
                    // Leg Movement (Forward/Backward rotation for stride)
                    LEG_GROUPS[0].rotation.x = step * ARM_SWING_ANGLE; // Right Leg
                    LEG_GROUPS[1].rotation.x = -step * ARM_SWING_ANGLE; // Left Leg

                    // Arm Swing (Opposite to legs, mainly Z rotation)
                    const armSwingZ = -step * ARM_SWING_ANGLE;
                    
                    // X-rotation reset for swinging
                    RIGHT_ARM.rotation.x = Math.PI * 0.6; 
                    LEFT_ARM.rotation.x = Math.PI * 0.6;
                    
                    // Smoothly transition to swing
                    RIGHT_ARM.rotation.z += (armSwingZ + Math.PI / 4 - RIGHT_ARM.rotation.z) * 0.2; 
                    LEFT_ARM.rotation.z += (-armSwingZ - Math.PI / 4 - LEFT_ARM.rotation.z) * 0.2; 
                    
                } else {
                    // Reset legs to standing position
                    LEG_GROUPS[0].rotation.x *= 0.8; 
                    LEG_GROUPS[1].rotation.x *= 0.8;
                    
                    // Arm reset (basic dribble/hold position)
                    const armXReset = Math.PI * 0.6;
                    RIGHT_ARM.rotation.x += (armXReset - RIGHT_ARM.rotation.x) * 0.1;
                    LEFT_ARM.rotation.x += (armXReset - LEFT_ARM.rotation.x) * 0.1;

                    const armZRightReset = Math.PI / 4;
                    const armZLeftReset = -Math.PI / 4;

                    RIGHT_ARM.rotation.z += (armZRightReset - RIGHT_ARM.rotation.z) * 0.1; 
                    LEFT_ARM.rotation.z += (armZLeftReset - LEFT_ARM.rotation.z) * 0.1; 
                }
            }
        }
        
        function updateMovementAndDribble() {
            gameClock += TIME_STEP;

            if (isShooting && !isGuaranteedShot) {
                // Player is locked after physics shot is released
            } else {
                // Movement
                const dirX = (keysPressed.d ? 1 : 0) - (keysPressed.a ? 1 : 0);
                const dirZ = (keysPressed.s ? 1 : 0) - (keysPressed.w ? 1 : 0);

                if (!isCharging) {
                    player.position.x += dirX * PLAYER_SPEED; 
                    player.position.z += dirZ * PLAYER_SPEED;
                    
                    // Boundary checks
                    player.position.x = Math.max(-(FENCE_X - 1), Math.min(FENCE_X - 1, player.position.x)); 
                    player.position.z = Math.max(-FENCE_Z + 1, Math.min(FENCE_Z - 1, player.position.z)); 
                }

                if (dirX !== 0 || dirZ !== 0) {
                    const targetAngle = Math.atan2(dirX, dirZ); 
                    const SMOOTH_ROTATION = 0.2; 
                    player.rotation.y += (targetAngle - player.rotation.y) * SMOOTH_ROTATION;
                }
            }

            // Apply jump physics
            if (isJumping) {
                player.userData.verticalVelocity += GRAVITY.y * TIME_STEP;
                player.position.y += player.userData.verticalVelocity * TIME_STEP;
                
                if (player.position.y <= GROUND_Y) {
                    player.position.y = GROUND_Y;
                    player.userData.verticalVelocity = 0;
                    isJumping = false;
                }
            }
            
            // --- Dribble Logic / Holding Ball Position ---
            
            if (isShooting) {
                 // Ball is now physics-controlled (or animated if guaranteed)
                if (isGuaranteedShot) {
                    shotProgress += TIME_STEP;
                    const t = Math.min(1, shotProgress / shotDuration);
                    
                    // Bezier Curve for a smooth arc
                    const targetPos = shotTargetPos;
                    const midPoint = shotStartPos.clone().lerp(targetPos, 0.5);
                    // Add arc height
                    midPoint.y = Math.max(shotStartPos.y, targetPos.y) + 4; 
                    
                    const p0 = shotStartPos;
                    const p1 = midPoint;
                    const p2 = targetPos;
                    
                    // Quadratic Bezier Interpolation
                    ball.position.x = (1-t) * (1-t) * p0.x + 2 * (1-t) * t * p1.x + t * t * p2.x;
                    ball.position.y = (1-t) * (1-t) * p0.y + 2 * (1-t) * t * p1.y + t * t * p2.y;
                    ball.position.z = (1-t) * (1-t) * p0.z + 2 * (1-t) * t * p1.z + t * t * p2.z;
                    
                    // Check for scoring (end of animation)
                    if (t >= 1) {
                        updateScore(player.position.distanceTo(RIM_CENTER) > 6.75 ? 3 : 2);
                        resetBall();
                    }
                }
            } else if (isCharging || isJumping) {
                // Lock ball to the actual right hand position
                const hand = player.userData.rightHand;
                const handWorldPosition = new THREE.Vector3();
                hand.getWorldPosition(handWorldPosition);
                ball.position.copy(handWorldPosition);
                
            } else if (isMoving) {
                // Dribble animation (only when moving)
                const bounceY = Math.abs(Math.sin(gameClock * DRIBBLE_RATE)) * DRIBBLE_HEIGHT;
                
                // Position ball to the side of the player based on orientation
                ball.position.set(
                    player.position.x + 0.5 * Math.sin(player.rotation.y + Math.PI/2), // Offset to the side of the player
                    player.position.y + 0.5 + bounceY, 
                    player.position.z + 0.5 * Math.cos(player.rotation.y + Math.PI/2)
                );
            } else if (isIdle) {
                // **3. Idle Dribble (Cross-Hand)**
                const bounceY = Math.abs(Math.sin(gameClock * DRIBBLE_RATE)) * 0.3; // Less bounce for idle
                const handSwitchX = Math.sin(gameClock * 5) * 0.6; // Switches between -0.6 (Left) and 0.6 (Right)
                
                ball.position.set(
                    player.position.x + handSwitchX, 
                    player.position.y + 0.2 + bounceY, 
                    player.position.z - 0.5 
                );
            } else {
                 // Holding the ball (Idle) - fallback when neither moving, charging, nor strictly idle
                 ball.position.set(
                    player.position.x + 0.2, 
                    player.position.y + 1.2, 
                    player.position.z - 1 
                );
            }
            
            // If the ball is locked to the player, keep its rotation static
            if(!isShooting) ball.rotation.set(0, 0, 0); 

            // --- Camera Tracking (LERP) ---
            if (currentCameraView === 'player') { 
                const CAMERA_SMOOTHNESS = 0.05;
                const targetX = player.position.x;
                const targetY = player.position.y + 5;
                const targetZ = player.position.z + 10;
                
                camera.position.z += (targetZ - camera.position.z) * CAMERA_SMOOTHNESS;
                camera.position.x += (targetX - camera.position.x) * CAMERA_SMOOTHNESS;
                camera.position.y += (targetY - camera.position.y) * CAMERA_SMOOTHNESS;

                camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
            } else {
                 // Goal View (fixed behind the backboard)
                const targetX = 0;
                const targetY = RIM_Y_POS + 1.5;
                const targetZ = RIM_Z_POS - 6; 
                
                const CAMERA_SMOOTHNESS = 0.1;

                camera.position.x += (targetX - camera.position.x) * CAMERA_SMOOTHNESS;
                camera.position.y += (targetY - camera.position.y) * CAMERA_SMOOTHNESS;
                camera.position.z += (targetZ - camera.position.z) * CAMERA_SMOOTHNESS;
                
                camera.lookAt(RIM_CENTER);
            }
            
            // Update UI elements based on state
            updatePlayerAnimations();
            updateOpponentAI();
        }

        /**
         * The core physics simulation for the launched ball.
         */
        function updatePhysics() {
            if (!isShooting || isGuaranteedShot) return;

            // 1. Apply Gravity and Update Position (Euler Integration)
            ballVelocity.add(GRAVITY.clone().multiplyScalar(TIME_STEP));
            ball.position.add(ballVelocity.clone().multiplyScalar(TIME_STEP));

            // 2. Apply Rotation (Spin)
            const rotationAxisX = new THREE.Vector3(1, 0, 0);
            const rotationAxisY = new THREE.Vector3(0, 1, 0);
            const rotationAxisZ = new THREE.Vector3(0, 0, 1);

            // Rotate based on angular velocity (in radians per second)
            ball.rotateOnWorldAxis(rotationAxisX, ballAngularVelocity.x * TIME_STEP);
            ball.rotateOnWorldAxis(rotationAxisY, ballAngularVelocity.y * TIME_STEP);
            ball.rotateOnWorldAxis(rotationAxisZ, ballAngularVelocity.z * TIME_STEP);

            // 3. Collision Checks

            // --- A. Ground Collision ---
            if (ball.position.y <= GROUND_Y + BALL_RADIUS) {
                ball.position.y = GROUND_Y + BALL_RADIUS;
                ballVelocity.y = -ballVelocity.y * BOUNCE_DAMPING; // Reverse and dampen
                ballVelocity.multiplyScalar(0.9); // Friction
                ballAngularVelocity.multiplyScalar(0.7); // Damping on spin
                
                // If velocity is very low, stop movement
                if (ballVelocity.length() < 1) {
                    ballVelocity.set(0, 0, 0);
                    ballAngularVelocity.set(0, 0, 0);
                    resetBall();
                }
            }
            
            // --- B. Fence Collisions ---
            FENCES.forEach(fence => {
                const fPos = fence.userData.pos;
                const fAxis = fence.userData.axis;

                if (fAxis === 'x') {
                    if (Math.abs(ball.position.x - fPos) <= BALL_RADIUS) {
                        ball.position.x = fPos + (ball.position.x > fPos ? BALL_RADIUS : -BALL_RADIUS);
                        ballVelocity.x = -ballVelocity.x * BOUNCE_DAMPING;
                        ballVelocity.multiplyScalar(0.9);
                    }
                } else if (fAxis === 'z') {
                    if (Math.abs(ball.position.z - fPos) <= BALL_RADIUS) {
                        ball.position.z = fPos + (ball.position.z > fPos ? BALL_RADIUS : -BALL_RADIUS);
                        ballVelocity.z = -ballVelocity.z * BOUNCE_DAMPING;
                        ballVelocity.multiplyScalar(0.9);
                    }
                }
            });


            // --- C. Backboard Collision ---
            const backboard = hoop.userData.backboardMesh;
            const BACKBOARD_Z = hoop.userData.BACKBOARD_Z_POS;

            if (ball.position.z <= BACKBOARD_Z + BALL_RADIUS && ballVelocity.z < 0) {
                // Check if ball hits within backboard bounds
                if (Math.abs(ball.position.x) < hoop.userData.BACKBOARD_X_HALF + BALL_RADIUS &&
                    ball.position.y > hoop.userData.BACKBOARD_Y_MIN &&
                    ball.position.y < hoop.userData.BACKBOARD_Y_MAX + BALL_RADIUS) {
                    
                    // Collision detected
                    ball.position.z = BACKBOARD_Z + BALL_RADIUS; // Correct position
                    ballVelocity.z = -ballVelocity.z * RIM_DAMPING; // Reverse and dampen
                    ballVelocity.y *= 0.95; // Dampen vertical velocity slightly
                    updateMessage("Hit the backboard!");
                }
            }


            // --- D. Rim Collision (Simplified Torus/Sphere Check) ---
            const rimDist = ball.position.clone().setY(RIM_Y_POS).distanceTo(RIM_CENTER.clone().setY(RIM_Y_POS));

            if (Math.abs(ball.position.y - RIM_Y_POS) < BALL_RADIUS + RIM_THICKNESS / 2) {
                if (Math.abs(rimDist - RIM_RADIUS) < BALL_RADIUS + RIM_THICKNESS / 2) {
                    // Collision with the rim torus
                    
                    // Calculate collision normal (vector from rim edge center to ball center)
                    const dir = ball.position.clone().setY(RIM_Y_POS).sub(RIM_CENTER.clone().setY(RIM_Y_POS)).normalize();
                    const pointOnRim = RIM_CENTER.clone().setY(RIM_Y_POS).add(dir.clone().multiplyScalar(RIM_RADIUS));
                    const normal = ball.position.clone().sub(pointOnRim).normalize();

                    // Reflect velocity
                    const velMagnitude = ballVelocity.dot(normal);
                    ballVelocity.sub(normal.clone().multiplyScalar((1 + RIM_DAMPING) * velMagnitude));
                    ballVelocity.multiplyScalar(0.9); // Extra friction/damping

                    // Correct position to prevent sinking
                    ball.position.add(normal.clone().multiplyScalar(0.01)); 
                    updateMessage("DINK!");
                }
            }
            
            // --- E. Net/Scoring Check ---
            // If the ball is above the rim and moving downwards, it's considered for scoring
            if (ball.position.y > RIM_Y_POS && ballVelocity.y < 0 && !ball.userData.scored) {
                const horizDist = ball.position.clone().setY(RIM_Y_POS).distanceTo(RIM_CENTER.clone().setY(RIM_Y_POS));
                
                if (horizDist < RIM_RADIUS - BALL_RADIUS * 0.5) { // Needs to pass cleanly inside the radius
                    ball.userData.inRimArea = true;
                }
            }
            
            // Check if ball passed through the rim plane
            if (ball.position.y <= RIM_Y_POS && ball.userData.inRimArea && !ball.userData.scored) {
                ball.userData.scored = true;
                // Determine 2 or 3 points
                const points = player.position.distanceTo(RIM_CENTER) > 6.75 ? 3 : 2; 
                updateScore(points);
            }
        }
        
        /**
         * Simple AI to track the player.
         */
        function updateOpponentAI() {
            const playerPos = player.position;
            const oppPos = opponent.position;

            // Only defend if the player is in range
            const distToPlayer = oppPos.distanceTo(playerPos);
            if (distToPlayer > AI_PLAYER_FOLLOW_DIST) {
                // Return to default position
                const defaultPos = new THREE.Vector3(0, GROUND_Y, AI_DEFENSE_Z);
                oppPos.lerp(defaultPos, 0.02);
                return;
            }

            // Move laterally to cut off the player
            const targetX = playerPos.x * 0.8; // Stick near the center
            const targetZ = Math.min(AI_DEFENSE_Z, playerPos.z - 3); // Stay between player and hoop

            const targetPos = new THREE.Vector3(targetX, GROUND_Y, targetZ);
            
            // Slow down when close to target
            const speed = AI_SPEED * (isShooting ? 0.5 : 1.0); // Less aggressive when ball is shot
            oppPos.lerp(targetPos, speed * TIME_STEP * 10);

            // Face the player
            opponent.lookAt(playerPos.x, playerPos.y, playerPos.z);
            opponent.rotation.x = 0; // Prevent looking up/down
            opponent.rotation.z = 0;
        }

        /**
         * The main game loop.
         */
        function animate() {
            requestAnimationFrame(animate);

            updateMovementAndDribble();
            updatePhysics();
            
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---

        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w': keysPressed.w = true; break;
                case 'a': keysPressed.a = true; break;
                case 's': keysPressed.s = true; break;
                case 'd': keysPressed.d = true; break;
                case 'e': 
                    if (!isShooting && !isCharging) {
                        isCharging = true;
                        chargeStartTime = performance.now();
                        
                        // NEW LOGIC: Set Layup state and display correct meter
                        player.userData.isLayup = isInThePaint();
                        
                        if (player.userData.isLayup) {
                            document.getElementById('layup-meter-container').style.display = 'block';
                            document.getElementById('jumpshot-meter-container').style.display = 'none';
                            player.userData.verticalVelocity = JUMP_VELOCITY * 0.8; // Higher jump for layup
                            isJumping = true; 
                            updateMessage("Charging Layup...");
                        } else {
                            document.getElementById('jumpshot-meter-container').style.display = 'block';
                            document.getElementById('layup-meter-container').style.display = 'none';
                            player.userData.verticalVelocity = JUMP_VELOCITY * 0.5; // Half speed for jumpshot crouch
                            isJumping = true;
                            updateMessage("Charging Jumpshot...");
                        }
                    }
                    keysPressed.e = true; 
                    break;
                case 'c':
                    const now = performance.now();
                    if (now - lastCKeyPressTime > 200) { // Debounce
                        currentCameraView = currentCameraView === 'player' ? 'goal' : 'player';
                        lastCKeyPressTime = now;
                    }
                    keysPressed.c = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w': keysPressed.w = false; break;
                case 'a': keysPressed.a = false; break;
                case 's': keysPressed.s = false; break;
                case 'd': keysPressed.d = false; break;
                case 'e':
                    if (isCharging) {
                        isCharging = false;
                        
                        // Hide both meters
                        document.getElementById('jumpshot-meter-container').style.display = 'none';
                        document.getElementById('layup-meter-container').style.display = 'none';
                        
                        const chargeTime = (performance.now() - chargeStartTime) / 1000;
                        
                        if (player.userData.isLayup) {
                            // Layup release logic
                            const maxTime = MAX_CHARGE_TIME_LAYUP;
                            const minWindow = maxTime * PERFECT_WINDOW_LAYUP_MIN;
                            const maxWindow = maxTime * PERFECT_WINDOW_LAYUP_MAX;
                            
                            // Power is calculated relative to the full charge time
                            let power = chargeTime / maxTime;
                            
                            if (chargeTime >= minWindow && chargeTime <= maxWindow) {
                                isGuaranteedShot = true;
                            } else {
                                isGuaranteedShot = false;
                            }
                            
                            launchLayup(power);

                        } else {
                            // Jumpshot release logic
                            const maxTime = MAX_CHARGE_TIME_JUMPSHOT;
                            const minWindow = maxTime * PERFECT_WINDOW_JUMPSHOT_MIN;
                            const maxWindow = maxTime * PERFECT_WINDOW_JUMPSHOT_MAX;
                            
                            let power = Math.min(1.8, chargeTime / (maxTime * 0.7)); 

                            if (chargeTime >= minWindow && chargeTime <= maxWindow) {
                                isGuaranteedShot = true;
                            } else {
                                isGuaranteedShot = false;
                            }
                            
                            launchJumpshot(power);
                        }
                    }
                    keysPressed.e = false;
                    break;
                case 'c': keysPressed.c = false; break;
            }
        }
        
        /**
         * Updates the shot meter's visual state while charging.
         */
        function updateShotMeter() {
             if (isCharging) {
                const chargeTime = (performance.now() - chargeStartTime) / 1000;
                
                if (player.userData.isLayup) {
                    // --- Vertical Layup Meter Update ---
                    const maxTime = MAX_CHARGE_TIME_LAYUP;
                    const progress = Math.min(1, chargeTime / maxTime);
                    const layupBar = document.getElementById('layup-bar');
                    layupBar.style.height = `${progress * 100}%`;
                    
                    if (progress >= 1) layupBar.style.background = 'red';
                    
                } else {
                    // --- Horizontal Jumpshot Meter Update ---
                    const maxTime = MAX_CHARGE_TIME_JUMPSHOT;
                    const progress = Math.min(1, chargeTime / maxTime);
                    const shotBar = document.getElementById('jumpshot-bar');
                    const shotTarget = document.getElementById('jumpshot-target');

                    shotBar.style.width = `${progress * 100}%`;
                    
                    // Adjust target width/position based on difficulty (e.g., further shots narrow the target)
                    const distance = player.position.distanceTo(RIM_CENTER);
                    const targetBaseWidth = 10;
                    const targetWidth = Math.max(4, targetBaseWidth - distance * 0.5); // Narrows target with distance
                    const targetLeft = 50 - targetWidth / 2;

                    shotTarget.style.width = `${targetWidth}%`;
                    shotTarget.style.left = `${targetLeft}%`;
                    
                    // Flash meter if overcharged
                    if (progress >= 1) shotBar.style.background = 'red';
                }
            }
        }

        // --- Initialization ---

        function init() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3a3a5a);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 5, 10); 

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Game Objects
            createCourt();
            createHoop();
            createBall();
            createPlayer();
            createOpponent();
            resetBall(); // Position ball at start

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            // Loop for non-physics UI updates
            setInterval(updateShotMeter, 50);

            // Start the game loop
            animate();
        }

        init();
    </script>
</body>
</html>
