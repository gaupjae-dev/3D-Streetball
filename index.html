<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Streetball Shooter - Layups and AI Defender</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 80vh;
            max-height: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            background-color: #2e2e4f;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            color: #ffffff;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        #score, #message {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 0.9rem;
            text-align: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 10;
        }
        /* Highlight the new instructions */
        #instructions strong {
            color: #00ffaa;
            text-shadow: 0 0 5px #00ffaa;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Shot Meter Styling */
        #shot-meter-container {
            position: absolute;
            bottom: 50px; 
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #shot-bar {
            height: 100%;
            width: 0%;
            /* Gradient: Red (too little) -> Yellow (good) -> Green (perfect) -> Yellow -> Red (too much) */
            background: linear-gradient(90deg, 
                rgba(255, 0, 0, 0.9), 
                rgba(255, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 50%, 
                rgba(255, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: width 0.01s linear;
        }
        #shot-target {
            position: absolute;
            top: 0;
            left: 45%; 
            width: 10%;
            height: 100%;
            border-left: 2px solid rgba(0, 0, 0, 0.8);
            border-right: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score">Score: 0</div>
            <div id="message">Streetball Ready!</div>
        </div>
        <div id="instructions">
            Use W, A, S, D to move. HOLD E for Jumpshot. **PRESS SPACE** to **JUMP/LAYUP** (when close)!
        </div>
        <div id="shot-meter-container">
            <div id="shot-bar"></div>
            <div id="shot-target"></div>
        </div>
    </div>

    <script type="module">
        // --- Global Variables ---
        let scene, camera, renderer;
        let ball, hoop, court, player, opponent;
        let score = 0;
        let isShooting = false;
        let ballVelocity = new THREE.Vector3();
        const GRAVITY = new THREE.Vector3(0, -9.8, 0); // Approx gravity (m/s^2)
        const TIME_STEP = 1/60; // Fixed physics step

        // State for Shot Meter and Perfect Shot Animation
        let isCharging = false;
        let chargeStartTime = 0;
        const MAX_CHARGE_TIME = 1.5; 
        let isGuaranteedShot = false; 
        let shotProgress = 0;
        let shotStartPos = new THREE.Vector3();
        const shotTargetPos = new THREE.Vector3(0, 3.05, -8); // Center of the rim
        let shotDuration = 0; 
        
        // Layup/Jump Variables
        const JUMP_VELOCITY = 6; 
        let isJumping = false;
        const GROUND_Y = -0.24; // -BALL_RADIUS
        const LAYUP_DISTANCE = 5; // Max Z distance for a layup
        
        // Variables for movement and dribbling
        const PLAYER_SPEED = 0.15; 
        const DRIBBLE_HEIGHT = 0.6; 
        const DRIBBLE_RATE = 10; 
        let keysPressed = { w: false, a: false, s: false, d: false, e: false, space: false }; 
        let gameClock = 0;

        // Hoop and Ball constants
        const BALL_RADIUS = 0.24;
        const RIM_Y_POS = 3.05; 
        const RIM_Z_POS = -8; 
        const RIM_THICKNESS = 0.02; 
        const BOUNCE_DAMPING = 0.6; 

        // Court Boundaries for fence
        const FENCE_X = 15;
        const FENCE_Z = 20;
        const FENCE_HEIGHT = 5;

        // Player model constants
        const BODY_COLOR = 0x00aaff; 
        const SHORTS_COLOR = 0x0088cc; 
        const SKIN_COLOR = 0xffdbac; 
        
        // Camera smooth follow factor
        const CAMERA_SMOOTHNESS = 0.05;
        
        // AI Defender Constants
        const AI_SPEED = 0.1;
        const AI_MAX_DIST_X = 10; // Max horizontal movement range
        const AI_DEFENSE_Z = -5;  // Defense zone Z coordinate
        const AI_PLAYER_FOLLOW_DIST = 15; // Max distance AI will chase player
        const AI_BLOCK_RADIUS = 2; // How close the AI needs to be to affect a shot (simple)


        // --- Utility Functions (Keep the ones from previous steps) ---

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            updateMessage(`SWISH! +${points} points!`);
        }

        function createFences() {
            // ... (Fences code remains the same) ...
            const FENCE_THICKNESS = 0.1;
            const fenceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a4a4a, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            const lineY = -BALL_RADIUS + 0.005; 
            const wallY = lineY + FENCE_HEIGHT / 2;

            const sideWallGeo = new THREE.BoxGeometry(FENCE_THICKNESS, FENCE_HEIGHT, 40);
            const leftFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            leftFence.position.set(-FENCE_X, wallY, 0);
            scene.add(leftFence);
            const rightFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            rightFence.position.set(FENCE_X, wallY, 0);
            scene.add(rightFence);

            const baseWallGeo = new THREE.BoxGeometry(30.1 + FENCE_THICKNESS, FENCE_HEIGHT, FENCE_THICKNESS); 
            const backFence = new THREE.Mesh(baseWallGeo, fenceMaterial);
            backFence.position.set(0, wallY, -FENCE_Z);
            scene.add(backFence);
        }

        function createCourt() {
            // ... (Court and Lines code remains the same) ...
            const groundGeometry = new THREE.PlaneGeometry(30, 40);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            court = new THREE.Mesh(groundGeometry, groundMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -BALL_RADIUS; 
            court.receiveShadow = true; 
            scene.add(court);

            createFences(); 

            // Court Lines
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineY = -BALL_RADIUS + 0.005;

            // Three-Point Arc
            const threePtRadius = 6.75;
            const arcShape = new THREE.Shape();
            arcShape.absarc(0, RIM_Z_POS, threePtRadius, Math.PI * 0.35, Math.PI * 0.65, true); 
            const arcPoints = arcShape.getPoints(50); 
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMesh = new THREE.Line(arcGeometry, lineMaterial);
            arcMesh.position.y = lineY;
            arcMesh.rotation.x = Math.PI / 2;
            scene.add(arcMesh);

            // Three-Point Wings
            const wingX = 6.75; 
            const wingLineGeo = new THREE.BoxGeometry(0.1, 0.01, 12); 
            const leftWing = new THREE.Mesh(wingLineGeo, lineMaterial);
            leftWing.position.set(-wingX, lineY, 3); 
            scene.add(leftWing);
            const rightWing = new THREE.Mesh(wingLineGeo, lineMaterial);
            rightWing.position.set(wingX, lineY, 3); 
            scene.add(rightWing);

            // Perimeter Lines
            const baseLineGeo = new THREE.BoxGeometry(30.1, 0.01, 0.1); 
            const sideLineGeo = new THREE.BoxGeometry(0.1, 0.01, 40);

            const leftSide = new THREE.Mesh(sideLineGeo, lineMaterial);
            leftSide.position.set(-FENCE_X, lineY, 0);
            scene.add(leftSide);

            const rightSide = new THREE.Mesh(sideLineGeo, lineMaterial);
            rightSide.position.set(FENCE_X, lineY, 0);
            scene.add(rightSide);

            const frontBase = new THREE.Mesh(baseLineGeo, lineMaterial); 
            frontBase.position.set(0, lineY, FENCE_Z);
            scene.add(frontBase);

            const backBase = new THREE.Mesh(baseLineGeo, lineMaterial); 
            backBase.position.set(0, lineY, -FENCE_Z);
            scene.add(backBase);
        }

        function createHoop() {
            // ... (Hoop code remains the same) ...
            hoop = new THREE.Group();

            // Dimensions
            const BACKBOARD_WIDTH = 1.83; 
            const BACKBOARD_HEIGHT = 1.07; 
            const BACKBOARD_THICKNESS = 0.03;
            const RIM_RADIUS = 0.228; 
            const RIM_THICKNESS_VISUAL = 0.02; 
            const POLE_OFFSET_Z = 1.2; 

            // Backboard
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8
            });
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_Y_POS + BACKBOARD_HEIGHT / 2 - 0.1, RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2);
            backboard.castShadow = true;
            backboard.receiveShadow = true;
            hoop.add(backboard);

            // Rim
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_THICKNESS_VISUAL / 2, 16, 50);
            const rimMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_Y_POS, RIM_Z_POS);
            rim.castShadow = true;
            hoop.add(rim);

            // Net
            const NET_HEIGHT = 0.45; 
            const NET_BOTTOM_RADIUS = 0.1;
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, NET_BOTTOM_RADIUS, NET_HEIGHT, 32, 1, true);
            const netMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, RIM_Y_POS - NET_HEIGHT / 2, RIM_Z_POS);
            hoop.add(net);
            
            // Pole
            const poleHeight = RIM_Y_POS + BACKBOARD_HEIGHT + 1.0; 
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, poleHeight, 16);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, poleHeight / 2 - BALL_RADIUS, RIM_Z_POS - POLE_OFFSET_Z);
            pole.castShadow = true;
            hoop.add(pole);
            
            hoop.position.set(0, 0, 0); 
            scene.add(hoop);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xff8c00, specular: 0x222222, shininess: 30
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            scene.add(ball);
        }

        function createPlayer() {
            // ... (Player model creation code remains the same) ...
            const playerGroup = new THREE.Group();
            
            const headRadius = 0.2;
            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const limbWidth = 0.1;
            const legHeight = 0.9;
            const armLength = 0.6; 
            
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: BODY_COLOR }); 
            const skinMaterial = new THREE.MeshLambertMaterial({ color: SKIN_COLOR }); 
            const shortsMaterial = new THREE.MeshLambertMaterial({ color: SHORTS_COLOR }); 
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); 

            // Head
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = legHeight + torsoHeight - headRadius * 0.2; 
            playerGroup.add(head);

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16); 
            const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2; 
            playerGroup.add(torso);
            
            // Right Arm Group (Articulated)
            const upperArmLength = armLength * 0.5;
            const lowerArmLength = armLength * 0.5;
            const upperArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.8, limbWidth * 0.8, upperArmLength, 8);
            const lowerArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.7, limbWidth * 0.7, lowerArmLength, 8);
            const handGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); 

            const rightArmGroup = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.x = upperArmLength / 2; 
            rightUpperArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightUpperArm);
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            rightLowerArm.position.x = upperArmLength + lowerArmLength / 2; 
            rightLowerArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightLowerArm);
            const rightHand = new THREE.Mesh(handGeometry, skinMaterial); // Tagged Hand
            rightHand.position.x = upperArmLength + lowerArmLength + 0.05; 
            rightArmGroup.add(rightHand);
            rightArmGroup.position.set(torsoRadius, legHeight + torsoHeight * 0.7, 0); 
            playerGroup.add(rightArmGroup);

            // Left Arm Group
            const leftArmGroup = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.x = -upperArmLength / 2; 
            leftUpperArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftUpperArm);
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            leftLowerArm.position.x = -(upperArmLength + lowerArmLength / 2); 
            leftLowerArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftLowerArm);
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.x = -(upperArmLength + lowerArmLength + 0.05);
            leftArmGroup.add(leftHand);
            leftArmGroup.position.set(-torsoRadius, legHeight + torsoHeight * 0.7, 0);
            playerGroup.add(leftArmGroup);

            // Legs and Shoes (Simple groups)
            const legGeometry = new THREE.CylinderGeometry(limbWidth, limbWidth, legHeight, 8);
            
            const rightLegGroup = new THREE.Group();
            const rightLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            rightLeg.position.y = legHeight / 2;
            rightLegGroup.add(rightLeg);
            rightLegGroup.position.set(torsoRadius * 0.4, 0, 0);
            playerGroup.add(rightLegGroup);
            
            const leftLegGroup = new THREE.Group();
            const leftLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            leftLeg.position.y = legHeight / 2;
            leftLegGroup.add(leftLeg);
            leftLegGroup.position.set(-torsoRadius * 0.4, 0, 0);
            playerGroup.add(leftLegGroup);
            
            const shoeGeometry = new THREE.BoxGeometry(limbWidth * 2, 0.15, limbWidth * 3);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(torsoRadius * 0.4, legHeight * 0.05, 0.1); 
            playerGroup.add(rightShoe);
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-torsoRadius * 0.4, legHeight * 0.05, 0.1);
            playerGroup.add(leftShoe);
            
            playerGroup.position.set(0, GROUND_Y, 6);
            player = playerGroup;
            player.castShadow = true; 
            player.rotation.y = Math.PI; 
            
            player.userData.rightArmGroup = rightArmGroup; 
            player.userData.leftArmGroup = leftArmGroup;
            player.userData.rightHand = rightHand;
            player.userData.legGroups = [rightLegGroup, leftLegGroup];
            player.userData.verticalVelocity = 0; // New: for jump physics
            
            scene.add(player);
        }
        
        // --- NEW: Opponent Model ---
        function createOpponent() {
            const oppGroup = new THREE.Group();
            const oppBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 }); // Red Jersey
            const oppSkinMaterial = new THREE.MeshLambertMaterial({ color: 0x6e4a2c }); // Dark Skin

            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const legHeight = 0.9;

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16);
            const torso = new THREE.Mesh(torsoGeometry, oppBodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2;
            oppGroup.add(torso);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, oppSkinMaterial);
            head.position.y = legHeight + torsoHeight + 0.18;
            oppGroup.add(head);

            // Legs (Simple)
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, legHeight, 8);
            const rightLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            rightLeg.position.set(torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(rightLeg);
            const leftLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            leftLeg.position.set(-torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(leftLeg);
            
            oppGroup.position.set(0, GROUND_Y, -5); // Start on defense
            opponent = oppGroup;
            opponent.castShadow = true;
            opponent.userData.verticalVelocity = 0; // For future jump blocking
            
            scene.add(opponent);
        }

        function resetBall() {
            ballVelocity.set(0, 0, 0);
            isShooting = false;
            isGuaranteedShot = false;
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            document.getElementById('shot-meter-container').style.display = 'none';
            
            updateMessage("Ready to shoot! Hold E for shot, SPACE for layup/jump.");
            
            updateMovementAndDribble(); // Reset ball position to hand/dribble
        }

        // --- NEW: Layup Logic ---
        function launchLayup() {
            if (isShooting) return;

            // 1. Determine direction and initial speed
            const distZ = player.position.z - RIM_Z_POS;
            const distSq = player.position.clone().setY(0).distanceToSq(shotTargetPos.clone().setY(0));
            
            // Check for AI influence (simple block)
            const aiDistSq = opponent.position.clone().setY(0).distanceToSq(player.position.clone().setY(0));
            const isBlocked = aiDistSq < AI_BLOCK_RADIUS * AI_BLOCK_RADIUS && opponent.position.z < player.position.z;

            // Base layup velocity: fast and high, aiming slightly beyond the rim
            let vx = 0;
            let vy = 12;
            let vz = 12;
            
            // Apply slight randomness/error
            vz += (Math.random() - 0.5) * 2;
            vy += (Math.random() - 0.5) * 1;
            vx += (Math.random() - 0.5) * 0.5;

            // Apply AI block penalty
            if (isBlocked) {
                vy *= 0.7; // Lower the vertical launch (blocked)
                vz *= 0.8; // Reduce forward speed
                vx += (Math.random() > 0.5 ? 1 : -1) * 2; // Introduce large lateral error
                updateMessage("BLOCKED! Heavy Contest!");
            } else {
                updateMessage("LAYUP!");
            }

            // Set launch position and velocity
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            ballVelocity.set(vx, vy, -vz); // Z is negative (towards the hoop)
            
            isShooting = true;
            isJumping = false; // Reset jump state
            player.userData.verticalVelocity = 0; // Stop player jump
        }

        function launchBall(power) {
            if (isShooting) return;

            // 1. Set the initial launch position (player's hand height)
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);

            ball.position.copy(launchPosition); 

            isShooting = true;
            isJumping = false;
            player.userData.verticalVelocity = 0;

            if (isGuaranteedShot) {
                // Perfect shot takes the animation path
                shotProgress = 0;
                shotStartPos.copy(ball.position); 
                const distZ = Math.max(1, player.position.z - RIM_Z_POS);
                shotDuration = Math.min(2.0, 0.7 + distZ * 0.07); 
                return;
            }

            // --- Standard Physics Launch for REALISTIC MISSES ---
            const VELOCITY_SCALE = Math.min(1.5, power); 
            const distZ = Math.max(1, player.position.z - RIM_Z_POS); 
            
            const base_vz = distZ * 0.85; 
            const base_vy = 13 + distZ * 0.5; 
            
            const vz = base_vz * VELOCITY_SCALE; 
            const vy = base_vy * VELOCITY_SCALE; 
            
            let dx = 0;
            const idealPower = 1.0;
            
            if (power < idealPower - 0.3 || power > idealPower + 0.3) {
                const errorFactor = Math.abs(power - idealPower) * 2; 
                dx = (Math.random() - 0.5) * 1.5 * errorFactor; 
            } else {
                dx = (Math.random() - 0.5) * 0.2; 
            }

            ballVelocity.set(dx, vy, -vz);
        }

        function updateMovementAndDribble() {
            gameClock += TIME_STEP;

            if (isShooting && !isGuaranteedShot) return;

            const dirX = (keysPressed.d ? 1 : 0) - (keysPressed.a ? 1 : 0);
            const dirZ = (keysPressed.s ? 1 : 0) - (keysPressed.w ? 1 : 0);

            if (!isCharging) {
                if (keysPressed.d) {
                    player.position.x += PLAYER_SPEED; 
                    player.position.x = Math.min(player.position.x, FENCE_X - 1); 
                }
                if (keysPressed.a) {
                    player.position.x -= PLAYER_SPEED; 
                    player.position.x = Math.max(player.position.x, -(FENCE_X - 1)); 
                }
                if (keysPressed.w) {
                    player.position.z -= PLAYER_SPEED;
                    player.position.z = Math.max(player.position.z, -FENCE_Z + 1); 
                }
                if (keysPressed.s) {
                    player.position.z += PLAYER_SPEED;
                    player.position.z = Math.min(player.position.z, FENCE_Z - 1); 
                }

                if (dirX !== 0 || dirZ !== 0) {
                    const targetAngle = Math.atan2(dirX, dirZ); 
                    const SMOOTH_ROTATION = 0.2; 
                    player.rotation.y += (targetAngle - player.rotation.y) * SMOOTH_ROTATION;
                }
            }

            // Apply jump physics
            if (isJumping) {
                player.userData.verticalVelocity += GRAVITY.y * TIME_STEP;
                player.position.y += player.userData.verticalVelocity * TIME_STEP;
                
                // Landed
                if (player.position.y <= GROUND_Y) {
                    player.position.y = GROUND_Y;
                    player.userData.verticalVelocity = 0;
                    isJumping = false;
                }
            }
            
            // Dribble Logic / Holding Ball Position
            const isMovingOrCharging = keysPressed.w || keysPressed.a || keysPressed.d || keysPressed.s || isCharging || isJumping;
            
            if (isMovingOrCharging) {
                if (isCharging || isJumping) {
                    // Lock ball to the actual right hand position
                    const hand = player.userData.rightHand;
                    const handWorldPosition = new THREE.Vector3();
                    hand.getWorldPosition(handWorldPosition);
                    ball.position.copy(handWorldPosition);
                    
                } else {
                    // Dribble animation
                    const bounceY = Math.abs(Math.sin(gameClock * DRIBBLE_RATE)) * DRIBBLE_HEIGHT;
                    
                    ball.position.set(
                        player.position.x,
                        player.position.y + 0.5 + bounceY, 
                        player.position.z - 1
                    );
                }
            } else {
                // Holding the ball (Idle)
                ball.position.set(
                    player.position.x + 0.2, 
                    player.position.y + 1.2, 
                    player.position.z - 1 
                );
            }

            // --- Camera Tracking (LERP) ---
            camera.position.z += (player.position.z + 3 - camera.position.z) * CAMERA_SMOOTHNESS;
            camera.position.x += (player.position.x - camera.position.x) * CAMERA_SMOOTHNESS;
        }

        /**
         * Updates the player's pose based on game state (Charging, Layup, Idle).
         */
        function updatePlayerAnimation() {
            if (!player) return; 

            const rArm = player.userData.rightArmGroup;
            const lArm = player.userData.leftArmGroup; 
            
            // Player vertical position for arm calculation
            const playerHeightRatio = (player.position.y - GROUND_Y) / 0.3; // Max jump height approx 0.3m

            if (isCharging) {
                // Shot Charging Pose
                rArm.rotation.z += (Math.PI / 2 - rArm.rotation.z) * 0.1; 
                rArm.rotation.y += (-Math.PI / 8 - rArm.rotation.y) * 0.1; 
                lArm.rotation.z += (-Math.PI / 4 - lArm.rotation.z) * 0.1; 
                player.position.y += (GROUND_Y - 0.1 - player.position.y) * 0.1;

            } else if (isJumping) { 
                // Layup/Jump Pose
                // The higher the player, the higher the arm is
                const targetArmZ = Math.PI / 2 + Math.PI / 4 * Math.min(1, playerHeightRatio * 2); 
                rArm.rotation.z += (targetArmZ - rArm.rotation.z) * 0.2; 
                rArm.rotation.y += (0 - rArm.rotation.y) * 0.2; 
                
                // Non-shooting arm is straight down or slightly out
                lArm.rotation.z += (-Math.PI / 16 - lArm.rotation.z) * 0.2;
                
            } else if (isShooting) {
                // Shot Follow-through (Jumpshot or Layup release)
                rArm.rotation.z += (Math.PI * 1.5 - rArm.rotation.z) * 0.2;
                lArm.rotation.z += (0 - lArm.rotation.z) * 0.2;
                player.position.y += (GROUND_Y - player.position.y) * 0.1; // Fall back down if not handled by jump physics
                
            } else {
                // Idle / Dribbling Pose
                const dribbleSwing = Math.sin(gameClock * 5) * 0.05;
                rArm.rotation.z += (dribbleSwing - rArm.rotation.z) * 0.1;
                lArm.rotation.z += (-dribbleSwing - lArm.rotation.z) * 0.1;
                rArm.rotation.y = 0;
                lArm.rotation.y = 0;
                
                player.position.y = GROUND_Y; // Grounded
            }
        }
        
        // --- NEW: Opponent AI ---
        function updateOpponentAI() {
            if (!opponent || isShooting) return; // Opponent freezes when ball is in the air

            const playerPos = player.position;
            const oppPos = opponent.position;

            // 1. Determine Target X (Defensive or Following)
            let targetX = 0;
            let targetZ = AI_DEFENSE_Z;
            let isClose = oppPos.distanceTo(playerPos) < AI_PLAYER_FOLLOW_DIST;
            let isPlayerNearHoop = playerPos.z < 0; 

            if (isPlayerNearHoop && isClose) {
                // Man-to-man defense: follow player's X position closely
                targetX = playerPos.x;
                
                // Defense positioning: stay between the player and the rim
                targetZ = Math.min(oppPos.z, playerPos.z - 1.5, AI_DEFENSE_Z);
            } else {
                // Zone defense: return to the key
                targetX = 0;
                targetZ = AI_DEFENSE_Z;
            }

            // 2. Movement Vector
            const moveSpeed = AI_SPEED;
            const dx = targetX - oppPos.x;
            const dz = targetZ - oppPos.z;

            const distanceSq = dx * dx + dz * dz;

            if (distanceSq > 0.1) {
                // Normalize and apply speed
                const distance = Math.sqrt(distanceSq);
                oppPos.x += (dx / distance) * moveSpeed;
                oppPos.z += (dz / distance) * moveSpeed;
            }

            // 3. Clamping and Rotation
            oppPos.x = Math.min(FENCE_X - 1, Math.max(-(FENCE_X - 1), oppPos.x));
            
            // Always face the player (Simple)
            const angle = Math.atan2(playerPos.x - oppPos.x, playerPos.z - oppPos.z);
            opponent.rotation.y += (angle - opponent.rotation.y) * 0.1;
        }


        // ... (checkBallHoopCollision, quadraticBezier, updatePhysics remain the same) ...
        function checkBallHoopCollision() {
            // ... (Backboard and Rim collision check remains the same) ...
            const BACKBOARD_Z_POS = RIM_Z_POS - 0.228 - 0.03 / 2;
            if (ball.position.z < BACKBOARD_Z_POS + BALL_RADIUS && ball.position.z > BACKBOARD_Z_POS && ballVelocity.z < 0) {
                if (Math.abs(ball.position.x) < 0.915 && ball.position.y < RIM_Y_POS + 1.07) {
                    ballVelocity.z *= -BOUNCE_DAMPING; 
                    ball.position.z = BACKBOARD_Z_POS + BALL_RADIUS;
                    updateMessage("Backboard!");
                }
            }

            const RIM_RADIUS = 0.228;
            const rimCenter = new THREE.Vector3(0, RIM_Y_POS, RIM_Z_POS);
            const rimDist = ball.position.distanceTo(rimCenter);

            if (ball.position.y < RIM_Y_POS + RIM_THICKNESS / 2 && ball.position.y > RIM_Y_POS - BALL_RADIUS * 2) {
                if (rimDist < RIM_RADIUS + BALL_RADIUS + RIM_THICKNESS && rimDist > RIM_RADIUS - BALL_RADIUS - RIM_THICKNESS) {
                    const normal = ball.position.clone().sub(rimCenter).normalize();
                    if (normal.y > 0.5) normal.y = 0.5;
                    ballVelocity.reflect(normal).multiplyScalar(BOUNCE_DAMPING * 0.8);
                    ball.position.add(normal.multiplyScalar(0.05)); 
                    updateMessage("CLANK!");
                }
            }

            // Score Check
            const ballBottomY = ball.position.y - BALL_RADIUS;
            const RIM_TOP_Y = RIM_Y_POS + RIM_THICKNESS / 2;
            const RIM_BOTTOM_Y = RIM_Y_POS - RIM_THICKNESS / 2;
            
            if (ball.userData.inRimArea && ballBottomY < RIM_BOTTOM_Y && ballVelocity.y < 0) {
                if (rimDist < RIM_RADIUS - BALL_RADIUS / 2) { 
                    updateScore(3);
                    ballVelocity.y = -2; 
                    ballVelocity.x = 0;
                    ballVelocity.z = 0;
                    ball.userData.scored = true;
                    ball.userData.inRimArea = false;
                    return;
                }
            }

            if (!ball.userData.scored) {
                if (rimDist < RIM_RADIUS + BALL_RADIUS && ballBottomY < RIM_TOP_Y) {
                    ball.userData.inRimArea = true;
                } else {
                    ball.userData.inRimArea = false;
                }
            }

            // Reset after going way out of bounds
            if (ball.position.y < -10 || ball.position.z < -FENCE_Z - 5) {
                if (!ball.userData.scored) {
                    updateMessage("Missed! Ball out of play.");
                }
                resetBall();
            }
        }
        
        function quadraticBezier(p0, p1, p2, t, target) {
            const oneMinusT = 1 - t;
            const oneMinusTSquared = oneMinusT * oneMinusT;
            const tSquared = t * t;

            target.x = oneMinusTSquared * p0.x + 2 * oneMinusT * t * p1.x + tSquared * p2.x;
            target.y = oneMinusTSquared * p0.y + 2 * oneMinusT * t * p1.y + tSquared * p2.y;
            target.z = oneMinusTSquared * p0.z + 2 * oneMinusT * t * p1.z + tSquared * p2.z;
        }

        function updatePhysics() {
            if (!isShooting) return;

            if (isGuaranteedShot) {
                // Guaranteed Shot Animation Path (Bezier Curve)
                shotProgress += TIME_STEP / shotDuration;
                const t = Math.min(1.0, shotProgress);
                
                const cp_y = Math.max(shotStartPos.y, 4.0, (shotStartPos.y + shotTargetPos.y) / 2 + 1.5);
                const cp_z = (shotStartPos.z + shotTargetPos.z) / 2;
                const cp_x = shotStartPos.x * 0.5 + shotTargetPos.x * 0.5;

                const controlPoint = new THREE.Vector3(cp_x, cp_y, cp_z);
                const currentPos = new THREE.Vector3();
                
                quadraticBezier(shotStartPos, controlPoint, shotTargetPos, t, currentPos);
                
                const previousPos = ball.position.clone();
                ball.position.copy(currentPos);
                ballVelocity.copy(ball.position).sub(previousPos).divideScalar(TIME_STEP);
                
                if (t >= 1.0) {
                    ball.position.copy(shotTargetPos); 
                    ballVelocity.set(0, -2, 0); 
                    ball.userData.scored = true;
                    isGuaranteedShot = false; 
                    updateScore(3);
                    updateMessage("PERFECT RELEASE! SWISH!");
                }
                
                if (!ball.userData.scored) return; 

            } else {
                // Standard Parabolic Physics
                ballVelocity.addScaledVector(GRAVITY, TIME_STEP);
                ball.position.addScaledVector(ballVelocity, TIME_STEP);

                // Floor collision
                if (ball.position.y <= -BALL_RADIUS) {
                    ball.position.y = -BALL_RADIUS;
                    ballVelocity.y *= -BOUNCE_DAMPING; 
                    
                    ballVelocity.x *= 0.9;
                    ballVelocity.z *= 0.9;

                    if (ballVelocity.length() < 0.5) {
                        resetBall();
                        updateMessage(ball.userData.scored ? "Ball Reset." : "Try again!");
                        return;
                    }
                }

                checkBallHoopCollision();
            }

        }

        // --- Event Handlers (Updated for Spacebar) ---
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (keysPressed.hasOwnProperty(key)) {
                keysPressed[key] = true;
            }

            if (key === 'e' && !isShooting && !isCharging) {
                isCharging = true;
                chargeStartTime = gameClock;
                document.getElementById('shot-meter-container').style.display = 'block';
            }
            
            // NEW: Jump/Layup Trigger
            if (key === ' ' && !isShooting && !isJumping && !isCharging) {
                isJumping = true;
                player.userData.verticalVelocity = JUMP_VELOCITY;
                
                const distToHoop = player.position.clone().setY(0).distanceTo(shotTargetPos.clone().setY(0));
                
                if (distToHoop < LAYUP_DISTANCE) {
                    launchLayup();
                } else {
                    updateMessage("Jump! (Use 'E' to shoot at this distance)");
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (keysPressed.hasOwnProperty(key)) {
                keysPressed[key] = false;
            }
            
            // NEW: Jump key release does nothing unless Layup was not triggered
            if (key === ' ' && isJumping && !isShooting) {
                // Allows player to jump without shooting if far away
            }

            if (key === 'e' && isCharging) {
                isCharging = false;
                
                const chargeDuration = gameClock - chargeStartTime;
                let power = chargeDuration / MAX_CHARGE_TIME;
                const meterValue = power * 2; 

                if (meterValue >= 0.9 && meterValue <= 1.1) {
                    isGuaranteedShot = true;
                    updateMessage("PERFECT RELEASE! (Green Light)");
                    launchBall(1.0); 
                } else {
                    isGuaranteedShot = false;
                    power = Math.min(1.8, Math.max(0.2, power));
                    launchBall(power);
                    updateMessage(meterValue < 0.9 ? "Too short!" : "Too long!");
                }
                
                document.getElementById('shot-meter-container').style.display = 'none';
            }
        });

        function updateShotMeter() {
            if (!isCharging) return;

            const chargeDuration = gameClock - chargeStartTime;
            let power = chargeDuration / MAX_CHARGE_TIME;
            const meterValue = power * 2; 
            const meterWidth = Math.min(100, meterValue * 100); 

            const shotBar = document.getElementById('shot-bar');
            shotBar.style.width = `${meterWidth}%`;
            
            const isPerfectWindow = meterValue >= 0.9 && meterValue <= 1.1;
            const targetDiv = document.getElementById('shot-target');
            targetDiv.style.boxShadow = isPerfectWindow ? '0 0 15px rgba(0, 255, 0, 1)' : 'none';
        }

        // --- Main Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            updateMovementAndDribble();
            updatePlayerAnimation();
            updateOpponentAI(); // NEW AI Update
            updatePhysics();
            updateShotMeter();

            renderer.render(scene, camera);
        }

        // --- Initialization ---
        function init() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene, Camera, Renderer, Lighting, Fog (Same as before)
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 4, 10);
            camera.lookAt(0, 2, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x1a1a2e); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 50);

            // Create Game Elements
            createCourt();
            createHoop();
            createBall();
            createPlayer();
            createOpponent(); // NEW AI Defender
            resetBall(); 

            window.addEventListener('resize', onWindowResize);
            
            camera.position.set(player.position.x, player.position.y + 4, player.position.z + 10);

            animate();
        }

        init();
    </script>
</body>
</html>
