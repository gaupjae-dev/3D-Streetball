<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Streetball Shooter - NBA Court and Integrated Shot Logic</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark theme */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 80vh;
            max-height: 800px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            background-color: #2e2e4f;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            color: #ffffff;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        #score, #message {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 0.9rem;
            text-align: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 10;
        }
        /* Highlight the new instructions */
        #instructions strong {
            color: #00ffaa;
            text-shadow: 0 0 5px #00ffaa;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Shot Meter Styling */
        #shot-meter-container {
            position: absolute;
            bottom: 50px; 
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 20;
            display: none; /* Initially hidden */
        }
        #shot-bar {
            height: 100%;
            width: 0%;
            /* Gradient: Red (too little) -> Yellow (good) -> Green (perfect) -> Yellow -> Red (too much) */
            background: linear-gradient(90deg, 
                rgba(255, 0, 0, 0.9), 
                rgba(255, 255, 0, 0.9) 40%, 
                rgba(0, 255, 0, 0.9) 50%, 
                rgba(255, 255, 0, 0.9) 60%, 
                rgba(255, 0, 0, 0.9) 100%
            );
            transition: width 0.01s linear;
        }
        #shot-target {
            position: absolute;
            top: 0;
            left: 45%; 
            width: 10%;
            height: 100%;
            border-left: 2px solid rgba(0, 0, 0, 0.8);
            border-right: 2px solid rgba(0, 0, 0, 0.8);
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score">Score: 0</div>
            <div id="message">Streetball Ready!</div>
        </div>
        <div id="instructions">
            Use W, A, S, D to move. **HOLD E** to **JUMPSHOT (outside paint)** or **LAYUP (inside paint)**. 
            Press **C** to toggle **Goal View**!
        </div>
        <div id="shot-meter-container">
            <div id="shot-bar"></div>
            <div id="shot-target"></div>
        </div>
    </div>

    <script type="module">
        // --- Global Variables and Constants ---
        let scene, camera, renderer;
        let ball, hoop, court, player, opponent;
        let score = 0;
        let isShooting = false;
        let ballVelocity = new THREE.Vector3();
        const GRAVITY = new THREE.Vector3(0, -9.8, 0); 
        const TIME_STEP = 1/60; 

        // Shot Meter State
        let isCharging = false;
        let chargeStartTime = 0;
        const MAX_CHARGE_TIME = 1.5; 
        let isGuaranteedShot = false; 
        let shotProgress = 0;
        let shotStartPos = new THREE.Vector3();
        const shotTargetPos = new THREE.Vector3(0, 3.05, -8); 
        let shotDuration = 0; 
        
        // Player State
        const JUMP_VELOCITY = 6; 
        const JUMPSHOT_HEIGHT = 0.5; // Height player jumps for a jumpshot
        let isJumping = false;
        const GROUND_Y = -0.24; 
        const LAYUP_AREA_Z = 5.8; // Z-limit for the key (Approx 4.6m from hoop * 0.5 Scale) 
        const LAYUP_AREA_X = 2.5; // X-limit for the key (Approx 4.9m wide * 0.5 Scale)
        
        // Movement and Dribbling
        const PLAYER_SPEED = 0.15; 
        const DRIBBLE_HEIGHT = 0.6; 
        const DRIBBLE_RATE = 10; 
        let keysPressed = { w: false, a: false, s: false, d: false, e: false }; 
        let gameClock = 0;

        // Hoop and Ball constants
        const BALL_RADIUS = 0.24;
        const RIM_Y_POS = 3.05; 
        const RIM_Z_POS = -8; 
        const BOUNCE_DAMPING = 0.6; 

        // Court Boundaries 
        const FENCE_X = 15;
        const FENCE_Z = 20;
        
        // AI Defender Constants (simplified)
        const AI_SPEED = 0.1;
        const AI_DEFENSE_Z = -5;  
        const AI_PLAYER_FOLLOW_DIST = 15; 
        const AI_BLOCK_RADIUS = 2; 

        // Camera State
        let currentCameraView = 'player'; // 'player' or 'goal'

        // --- Utility Functions ---

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
            updateMessage(`SWISH! +${points} points!`);
        }

        // Check if player is inside the "paint" (the free throw key)
        function isInThePaint() {
            const pos = player.position;
            const zDistanceFromHoop = pos.z - RIM_Z_POS;
            return zDistanceFromHoop < LAYUP_AREA_Z && Math.abs(pos.x) < LAYUP_AREA_X;
        }

        function createFences() {
            const FENCE_THICKNESS = 0.1;
            const FENCE_HEIGHT = 5;
            const lineY = -BALL_RADIUS + 0.005; 
            const wallY = lineY + FENCE_HEIGHT / 2;
            const fenceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a4a4a, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            const sideWallGeo = new THREE.BoxGeometry(FENCE_THICKNESS, FENCE_HEIGHT, 40);
            const leftFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            leftFence.position.set(-FENCE_X, wallY, 0);
            scene.add(leftFence);
            const rightFence = new THREE.Mesh(sideWallGeo, fenceMaterial);
            rightFence.position.set(FENCE_X, wallY, 0);
            scene.add(rightFence);

            const baseWallGeo = new THREE.BoxGeometry(30.1 + FENCE_THICKNESS, FENCE_HEIGHT, FENCE_THICKNESS); 
            const backFence = new THREE.Mesh(baseWallGeo, fenceMaterial);
            backFence.position.set(0, wallY, -FENCE_Z);
            scene.add(backFence);
            
            // Out of bounds line at the front (closer to camera)
            const frontFence = new THREE.Mesh(baseWallGeo, fenceMaterial); 
            frontFence.position.set(0, wallY, FENCE_Z);
            scene.add(frontFence);
        }

        function createCourt() {
            const groundGeometry = new THREE.PlaneGeometry(30, 40);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            court = new THREE.Mesh(groundGeometry, groundMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -BALL_RADIUS; 
            court.receiveShadow = true; 
            scene.add(court);

            createFences(); 

            // Court Lines
            const LINE_WIDTH = 0.1;
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineY = -BALL_RADIUS + 0.005;

            // --- 1. NBA Perimeter Out-of-Bounds Lines ---
            const PERIMETER_X = 14.95;
            const PERIMETER_Z = 19.95;
            const lineGeoX = new THREE.BoxGeometry(LINE_WIDTH, 0.01, 40); 
            const lineGeoZ = new THREE.BoxGeometry(30, 0.01, LINE_WIDTH);

            // Side lines
            const leftSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            leftSideLine.position.set(-PERIMETER_X, lineY, 0);
            scene.add(leftSideLine);

            const rightSideLine = new THREE.Mesh(lineGeoX, lineMaterial);
            rightSideLine.position.set(PERIMETER_X, lineY, 0);
            scene.add(rightSideLine);

            // Base lines
            const frontBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            frontBaseLine.position.set(0, lineY, PERIMETER_Z);
            scene.add(frontBaseLine);

            const backBaseLine = new THREE.Mesh(lineGeoZ, lineMaterial);
            backBaseLine.position.set(0, lineY, -PERIMETER_Z);
            scene.add(backBaseLine);


            // --- 2. Free Throw Lane / Key ---
            const KEY_WIDTH = 4.9; // approx 16ft, 8ft each side
            const KEY_LENGTH = LAYUP_AREA_Z + (PERIMETER_Z - Math.abs(RIM_Z_POS)); // depth from the baseline

            // Side lines of the Key
            const keySideGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, KEY_LENGTH);
            const keySideZ = RIM_Z_POS + KEY_LENGTH / 2;

            const leftKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            leftKeyLine.position.set(-KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(leftKeyLine);

            const rightKeyLine = new THREE.Mesh(keySideGeo, lineMaterial);
            rightKeyLine.position.set(KEY_WIDTH / 2, lineY, keySideZ);
            scene.add(rightKeyLine);

            // Free Throw Line (The top of the key)
            const freeThrowLineGeo = new THREE.BoxGeometry(KEY_WIDTH + LINE_WIDTH, 0.01, LINE_WIDTH);
            const freeThrowLineZ = RIM_Z_POS + LAYUP_AREA_Z; 

            const freeThrowLine = new THREE.Mesh(freeThrowLineGeo, lineMaterial);
            freeThrowLine.position.set(0, lineY, freeThrowLineZ);
            scene.add(freeThrowLine);

            // Free Throw Circle
            const FT_RADIUS = 1.8; // 6ft
            const ftCircleShape = new THREE.Shape();
            ftCircleShape.absarc(0, freeThrowLineZ, FT_RADIUS, 0, Math.PI * 2, true);
            const ftCirclePoints = ftCircleShape.getPoints(50);
            const ftCircleGeometry = new THREE.BufferGeometry().setFromPoints(ftCirclePoints);
            const ftCircleMesh = new THREE.Line(ftCircleGeometry, lineMaterial);
            ftCircleMesh.position.y = lineY;
            ftCircleMesh.rotation.x = Math.PI / 2;
            scene.add(ftCircleMesh);

            // --- 3. Three-Point Arc ---
            const threePtRadius = 6.75;
            const arcShape = new THREE.Shape();
            arcShape.absarc(0, RIM_Z_POS, threePtRadius, Math.PI * 0.35, Math.PI * 0.65, true); 
            const arcPoints = arcShape.getPoints(50); 
            const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
            const arcMesh = new THREE.Line(arcGeometry, lineMaterial);
            arcMesh.position.y = lineY;
            arcMesh.rotation.x = Math.PI / 2;
            scene.add(arcMesh);

            // Three-Point Wings (connecting arc to sidelines)
            const wingZStart = RIM_Z_POS + Math.cos(Math.PI * 0.35) * threePtRadius;
            const wingLineLength = PERIMETER_Z - wingZStart; 
            const wingGeo = new THREE.BoxGeometry(LINE_WIDTH, 0.01, wingLineLength);
            
            const wingX = Math.sin(Math.PI * 0.35) * threePtRadius; 

            const leftWing = new THREE.Mesh(wingGeo, lineMaterial);
            leftWing.position.set(-wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, lineMaterial);
            rightWing.position.set(wingX, lineY, (wingZStart + PERIMETER_Z) / 2);
            scene.add(rightWing);
        }

        function createHoop() {
            hoop = new THREE.Group();

            // Dimensions
            const BACKBOARD_WIDTH = 1.83; 
            const BACKBOARD_HEIGHT = 1.07; 
            const BACKBOARD_THICKNESS = 0.03;
            const RIM_RADIUS = 0.228; 
            const RIM_THICKNESS_VISUAL = 0.02; 
            const POLE_OFFSET_Z = 1.2; 

            // Backboard
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8
            });
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_Y_POS + BACKBOARD_HEIGHT / 2 - 0.1, RIM_Z_POS - RIM_THICKNESS_VISUAL - BACKBOARD_THICKNESS / 2);
            backboard.castShadow = true;
            backboard.receiveShadow = true;
            hoop.add(backboard);

            // Rim
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_THICKNESS_VISUAL / 2, 16, 50);
            const rimMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_Y_POS, RIM_Z_POS);
            rim.castShadow = true;
            hoop.add(rim);

            // Net
            const NET_HEIGHT = 0.45; 
            const NET_BOTTOM_RADIUS = 0.1;
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, NET_BOTTOM_RADIUS, NET_HEIGHT, 32, 1, true);
            const netMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, RIM_Y_POS - NET_HEIGHT / 2, RIM_Z_POS);
            hoop.add(net);
            
            // Pole
            const poleHeight = RIM_Y_POS + BACKBOARD_HEIGHT + 1.0; 
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, poleHeight, 16);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, poleHeight / 2 - BALL_RADIUS, RIM_Z_POS - POLE_OFFSET_Z);
            pole.castShadow = true;
            hoop.add(pole);
            
            hoop.position.set(0, 0, 0); 
            scene.add(hoop);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xff8c00, specular: 0x222222, shininess: 30
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            scene.add(ball);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            const headRadius = 0.2;
            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const limbWidth = 0.1;
            const legHeight = 0.9;
            const armLength = 0.6; 
            
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00aaff }); 
            const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac }); 
            const shortsMaterial = new THREE.MeshLambertMaterial({ color: 0x0088cc }); 
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc }); 

            // Head
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = legHeight + torsoHeight - headRadius * 0.2; 
            playerGroup.add(head);

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16); 
            const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2; 
            playerGroup.add(torso);
            
            // Right Arm Group (Articulated)
            const upperArmLength = armLength * 0.5;
            const lowerArmLength = armLength * 0.5;
            const upperArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.8, limbWidth * 0.8, upperArmLength, 8);
            const lowerArmGeometry = new THREE.CylinderGeometry(limbWidth * 0.7, limbWidth * 0.7, lowerArmLength, 8);
            const handGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); 

            const rightArmGroup = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.x = upperArmLength / 2; 
            rightUpperArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightUpperArm);
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            rightLowerArm.position.x = upperArmLength + lowerArmLength / 2; 
            rightLowerArm.rotation.z = Math.PI / 2;
            rightArmGroup.add(rightLowerArm);
            const rightHand = new THREE.Mesh(handGeometry, skinMaterial); // Tagged Hand
            rightHand.position.x = upperArmLength + lowerArmLength + 0.05; 
            rightArmGroup.add(rightHand);
            rightArmGroup.position.set(torsoRadius, legHeight + torsoHeight * 0.7, 0); 
            playerGroup.add(rightArmGroup);

            // Left Arm Group
            const leftArmGroup = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.x = -upperArmLength / 2; 
            leftUpperArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftUpperArm);
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, skinMaterial);
            leftLowerArm.position.x = -(upperArmLength + lowerArmLength / 2); 
            leftLowerArm.rotation.z = -Math.PI / 2;
            leftArmGroup.add(leftLowerArm);
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.x = -(upperArmLength + lowerArmLength + 0.05);
            leftArmGroup.add(leftHand);
            leftArmGroup.position.set(-torsoRadius, legHeight + torsoHeight * 0.7, 0);
            playerGroup.add(leftArmGroup);

            // Legs and Shoes (Simple groups)
            const legGeometry = new THREE.CylinderGeometry(limbWidth, limbWidth, legHeight, 8);
            
            const rightLegGroup = new THREE.Group();
            const rightLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            rightLeg.position.y = legHeight / 2;
            rightLegGroup.add(rightLeg);
            rightLegGroup.position.set(torsoRadius * 0.4, 0, 0);
            playerGroup.add(rightLegGroup);
            
            const leftLegGroup = new THREE.Group();
            const leftLeg = new THREE.Mesh(legGeometry, shortsMaterial); 
            leftLeg.position.y = legHeight / 2;
            leftLegGroup.add(leftLeg);
            leftLegGroup.position.set(-torsoRadius * 0.4, 0, 0);
            playerGroup.add(leftLegGroup);
            
            const shoeGeometry = new THREE.BoxGeometry(limbWidth * 2, 0.15, limbWidth * 3);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(torsoRadius * 0.4, legHeight * 0.05, 0.1); 
            playerGroup.add(rightShoe);
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-torsoRadius * 0.4, legHeight * 0.05, 0.1);
            playerGroup.add(leftShoe);
            
            playerGroup.position.set(0, GROUND_Y, 6);
            player = playerGroup;
            player.castShadow = true; 
            player.rotation.y = Math.PI; 
            
            player.userData.rightArmGroup = rightArmGroup; 
            player.userData.leftArmGroup = leftArmGroup;
            player.userData.rightHand = rightHand;
            player.userData.legGroups = [rightLegGroup, leftLegGroup];
            player.userData.verticalVelocity = 0;
            player.userData.isLayup = false; // New: to distinguish layup from jumpshot
            
            scene.add(player);
        }
        
        function createOpponent() {
            const oppGroup = new THREE.Group();
            const oppBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 }); 
            const oppSkinMaterial = new THREE.MeshLambertMaterial({ color: 0x6e4a2c }); 

            const torsoHeight = 0.7;
            const torsoRadius = 0.25;
            const legHeight = 0.9;

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(torsoRadius, torsoRadius * 0.9, torsoHeight, 16);
            const torso = new THREE.Mesh(torsoGeometry, oppBodyMaterial);
            torso.position.y = legHeight + torsoHeight / 2;
            oppGroup.add(torso);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeometry, oppSkinMaterial);
            head.position.y = legHeight + torsoHeight + 0.18;
            oppGroup.add(head);

            // Legs (Simple)
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, legHeight, 8);
            const rightLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            rightLeg.position.set(torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(rightLeg);
            const leftLeg = new THREE.Mesh(legGeometry, oppBodyMaterial);
            leftLeg.position.set(-torsoRadius * 0.4, legHeight / 2, 0);
            oppGroup.add(leftLeg);
            
            oppGroup.position.set(0, GROUND_Y, -5); 
            opponent = oppGroup;
            opponent.castShadow = true;
            opponent.userData.verticalVelocity = 0; 
            
            scene.add(opponent);
        }

        function resetBall() {
            ballVelocity.set(0, 0, 0);
            isShooting = false;
            isGuaranteedShot = false;
            player.userData.isLayup = false;
            isJumping = false;
            player.userData.verticalVelocity = 0;
            player.position.y = GROUND_Y;
            
            ball.userData.scored = false;
            ball.userData.inRimArea = false;
            document.getElementById('shot-meter-container').style.display = 'none';
            
            updateMessage("Ready to shoot! Hold E to shoot.");
            
            updateMovementAndDribble(); 
        }

        function launchLayup() {
            if (isShooting) return;

            // Check for AI influence (simple block)
            const aiDistSq = opponent.position.clone().setY(0).distanceToSq(player.position.clone().setY(0));
            const isBlocked = aiDistSq < AI_BLOCK_RADIUS * AI_BLOCK_RADIUS && opponent.position.z < player.position.z;

            // Base layup velocity: fast and high, aiming slightly beyond the rim
            let vx = 0;
            let vy = 12;
            let vz = 12;
            
            // Apply slight randomness/error
            vz += (Math.random() - 0.5) * 2;
            vy += (Math.random() - 0.5) * 1;
            vx += (Math.random() - 0.5) * 0.5;

            // Apply AI block penalty
            if (isBlocked) {
                vy *= 0.7; // Lower the vertical launch (blocked)
                vz *= 0.8; // Reduce forward speed
                vx += (Math.random() > 0.5 ? 1 : -1) * 2; // Introduce large lateral error
                updateMessage("BLOCKED! Heavy Contest!");
            } else {
                updateMessage("LAYUP!");
            }

            // Set launch position and velocity
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);
            ball.position.copy(launchPosition); 
            ballVelocity.set(vx, vy, -vz); 
            
            isShooting = true;
            isJumping = false; 
            player.userData.verticalVelocity = 0; 
        }

        function launchJumpshot(power) {
            if (isShooting) return;

            // 1. Set the initial launch position (player's hand height)
            const launchPosition = new THREE.Vector3();
            player.userData.rightHand.getWorldPosition(launchPosition);

            ball.position.copy(launchPosition); 

            isShooting = true;
            isJumping = false;
            player.userData.verticalVelocity = 0;

            if (isGuaranteedShot) {
                // Perfect shot takes the animation path
                shotProgress = 0;
                shotStartPos.copy(ball.position); 
                const distZ = Math.max(1, player.position.z - RIM_Z_POS);
                shotDuration = Math.min(2.0, 0.7 + distZ * 0.07); 
                return;
            }

            // --- Standard Physics Launch for REALISTIC MISSES ---
            const VELOCITY_SCALE = Math.min(1.8, power); 
            const distZ = Math.max(1, player.position.z - RIM_Z_POS); 
            
            const base_vz = distZ * 0.85; 
            const base_vy = 13 + distZ * 0.5; 
            
            const vz = base_vz * VELOCITY_SCALE; 
            const vy = base_vy * VELOCITY_SCALE; 
            
            let dx = 0;
            const idealPower = 1.0;
            
            if (power < idealPower - 0.3 || power > idealPower + 0.3) {
                const errorFactor = Math.abs(power - idealPower) * 2; 
                dx = (Math.random() - 0.5) * 1.5 * errorFactor; 
            } else {
                dx = (Math.random() - 0.5) * 0.2; 
            }

            ballVelocity.set(dx, vy, -vz);
        }

        function updateMovementAndDribble() {
            gameClock += TIME_STEP;

            if (isShooting && !isGuaranteedShot) return;

            const dirX = (keysPressed.d ? 1 : 0) - (keysPressed.a ? 1 : 0);
            const dirZ = (keysPressed.s ? 1 : 0) - (keysPressed.w ? 1 : 0);

            if (!isCharging) {
                if (keysPressed.d) {
                    player.position.x += PLAYER_SPEED; 
                    player.position.x = Math.min(player.position.x, FENCE_X - 1); 
                }
                if (keysPressed.a) {
                    player.position.x -= PLAYER_SPEED; 
                    player.position.x = Math.max(player.position.x, -(FENCE_X - 1)); 
                }
                if (keysPressed.w) {
                    player.position.z -= PLAYER_SPEED;
                    player.position.z = Math.max(player.position.z, -FENCE_Z + 1); 
                }
                if (keysPressed.s) {
                    player.position.z += PLAYER_SPEED;
                    player.position.z = Math.min(player.position.z, FENCE_Z - 1); 
                }

                if (dirX !== 0 || dirZ !== 0) {
                    const targetAngle = Math.atan2(dirX, dirZ); 
                    const SMOOTH_ROTATION = 0.2; 
                    player.rotation.y += (targetAngle - player.rotation.y) * SMOOTH_ROTATION;
                }
            }

            // Apply jump physics
            if (isJumping) {
                player.userData.verticalVelocity += GRAVITY.y * TIME_STEP;
                player.position.y += player.userData.verticalVelocity * TIME_STEP;
                
                // Landed
                if (player.position.y <= GROUND_Y) {
                    player.position.y = GROUND_Y;
                    player.userData.verticalVelocity = 0;
                    isJumping = false;
                }
            }
            
            // Dribble Logic / Holding Ball Position
            const isMovingOrCharging = keysPressed.w || keysPressed.a || keysPressed.d || keysPressed.s || isCharging || isJumping;
            
            if (isMovingOrCharging) {
                if (isCharging || isJumping) {
                    // Lock ball to the actual right hand position
                    const hand = player.userData.rightHand;
                    const handWorldPosition = new THREE.Vector3();
                    hand.getWorldPosition(handWorldPosition);
                    ball.position.copy(handWorldPosition);
                    
                } else {
                    // Dribble animation
                    const bounceY = Math.abs(Math.sin(gameClock * DRIBBLE_RATE)) * DRIBBLE_HEIGHT;
                    
                    ball.position.set(
                        player.position.x,
                        player.position.y + 0.5 + bounceY, 
                        player.position.z - 1
                    );
                }
            } else {
                // Holding the ball (Idle)
                ball.position.set(
                    player.position.x + 0.2, 
                    player.position.y + 1.2, 
                    player.position.z - 1 
                );
            }

            // --- Camera Tracking (LERP) ---
            if (currentCameraView === 'player') { // CHECK THE VIEW
                const CAMERA_SMOOTHNESS = 0.05;
                // Target position behind and above the player
                const targetX = player.position.x;
                const targetY = player.position.y + 5;
                const targetZ = player.position.z + 10;
                
                camera.position.z += (targetZ - camera.position.z) * CAMERA_SMOOTHNESS;
                camera.position.x += (targetX - camera.position.x) * CAMERA_SMOOTHNESS;
                camera.position.y += (targetY - camera.position.y) * CAMERA_SMOOTHNESS;

                // Always look at the player
                camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
            }
        }

        /**
         * Updates the player's pose based on game state (Charging, Layup, Idle).
         */
        function updatePlayerAnimation() {
            if (!player) return; 

            const rArm = player.userData.rightArmGroup;
            const lArm = player.userData.leftArmGroup; 
            
            // Player vertical position for arm calculation
            const playerJumpRatio = (player.position.y - GROUND_Y) / (player.userData.isLayup ? JUMP_VELOCITY * TIME_STEP * 10 : JUMPSHOT_HEIGHT);

            if (isShooting) {
                // Shooting pose (arms up and forward)
                rArm.rotation.set(Math.PI * 0.2, 0, Math.PI * 0.3); // Up and forward
                lArm.rotation.set(Math.PI * 0.1, 0, -Math.PI * 0.1); 
                
            } else if (isCharging) {
                // Charging/Jump start pose (crouch and bring ball up)
                const chargeRatio = Math.min(1, (performance.now() - chargeStartTime) / (MAX_CHARGE_TIME * 1000));
                
                // Slight crouch
                player.position.y = GROUND_Y - chargeRatio * 0.2;
                
                // Arms move up and back for power
                rArm.rotation.set(Math.PI * 0.4 * chargeRatio, 0, Math.PI * 0.1); 
                lArm.rotation.set(Math.PI * 0.1, 0, -Math.PI * 0.1); 

            } else if (isJumping) {
                // Jumpshot/Layup apex pose
                const jumpRatio = Math.min(1, playerJumpRatio);
                
                // Arms up and slightly extended
                rArm.rotation.set(Math.PI * 0.2, 0, Math.PI * 0.3); 
                lArm.rotation.set(Math.PI * 0.1, 0, -Math.PI * 0.1); 

            } else {
                // Idle / Dribble / Running animation
                const movementFactor = keysPressed.w || keysPressed.a || keysPressed.s || keysPressed.d ? 1 : 0.5;
                const sineVal = Math.sin(gameClock * 15) * 0.3 * movementFactor;
                
                // Reset Y position
                player.position.y = GROUND_Y;

                // Arm swing/dribble motion
                rArm.rotation.set(0, 0, Math.PI * 0.2 + sineVal * 0.5);
                lArm.rotation.set(0, 0, -Math.PI * 0.2 - sineVal * 0.5);
                
                // Leg movement
                player.userData.legGroups[0].rotation.x = sineVal; 
                player.userData.legGroups[1].rotation.x = -sineVal;
            }
        }
        
        function updateAISimplified() {
            // Very basic AI: follow the player on the Z-axis, but stop at defense line
            const targetZ = Math.min(player.position.z + 1, AI_DEFENSE_Z);
            
            if (opponent.position.z > targetZ) {
                opponent.position.z -= AI_SPEED * TIME_STEP * 60;
                opponent.position.z = Math.max(opponent.position.z, targetZ);
            } else if (opponent.position.z < targetZ) {
                opponent.position.z += AI_SPEED * TIME_STEP * 60;
                opponent.position.z = Math.min(opponent.position.z, targetZ);
            }
            
            // Look at player
            opponent.lookAt(player.position.x, opponent.position.y + 1, player.position.z);
            opponent.rotation.x = 0;
            opponent.rotation.z = 0; 
            
            // AI animation (simple running/idle)
            const sineVal = Math.sin(gameClock * 10) * 0.3;
            opponent.children[3].rotation.x = sineVal; // right leg
            opponent.children[4].rotation.x = -sineVal; // left leg
        }

        function updateBallPhysics() {
            if (!isShooting) return;

            if (isGuaranteedShot) {
                // Perfect shot animation (parabola to the target)
                shotProgress += TIME_STEP / shotDuration;
                
                if (shotProgress >= 1) {
                    ball.position.copy(shotTargetPos);
                    updateScore(3); // Guaranteed to be a 3-pointer
                    isShooting = false;
                    setTimeout(resetBall, 2000);
                    return;
                }

                const t = shotProgress;
                // Bezier curve approximation: StartPos -> High Point (Middle) -> TargetPos
                const midPoint = shotStartPos.clone().lerp(shotTargetPos, 0.5);
                midPoint.y += 6; // Apex height

                // Quadratic Bezier interpolation
                const p1 = shotStartPos.clone().lerp(midPoint, t);
                const p2 = midPoint.clone().lerp(shotTargetPos, t);
                ball.position.copy(p1.lerp(p2, t));
                
            } else {
                // Standard ballistic motion
                ballVelocity.add(GRAVITY.clone().multiplyScalar(TIME_STEP));
                ball.position.add(ballVelocity.clone().multiplyScalar(TIME_STEP));
            
                // --- Collision Detection ---

                // 1. Court / Ground Collision
                if (ball.position.y < GROUND_Y + BALL_RADIUS) {
                    ball.position.y = GROUND_Y + BALL_RADIUS;
                    ballVelocity.y *= -BOUNCE_DAMPING; 
                    ballVelocity.multiplyScalar(0.9); // Friction
                    
                    if (ballVelocity.length() < 1) {
                         // Ball stops
                        resetBall();
                        updateMessage(ball.userData.scored ? "Buzzer beater!" : "Missed! Back to Dribble.");
                        return;
                    }
                }
                
                // 2. Fences (Out-of-Bounds)
                if (Math.abs(ball.position.x) > FENCE_X - BALL_RADIUS || Math.abs(ball.position.z) > FENCE_Z - BALL_RADIUS) {
                    // Simple inelastic collision response
                    if (Math.abs(ball.position.x) > FENCE_X - BALL_RADIUS) {
                        ball.position.x = Math.sign(ball.position.x) * (FENCE_X - BALL_RADIUS);
                        ballVelocity.x *= -0.7;
                    }
                    if (Math.abs(ball.position.z) > FENCE_Z - BALL_RADIUS) {
                        ball.position.z = Math.sign(ball.position.z) * (FENCE_Z - BALL_RADIUS);
                        ballVelocity.z *= -0.7;
                    }
                }

                // 3. Backboard Collision (Simplified: Plane)
                const BACKBOARD_PLANE_Z = RIM_Z_POS - 0.5;
                if (ball.position.z <= BACKBOARD_PLANE_Z + BALL_RADIUS && ballVelocity.z < 0 && ball.position.y < RIM_Y_POS + 1.0) {
                     if (Math.abs(ball.position.x) < 1.83 / 2) {
                        ball.position.z = BACKBOARD_PLANE_Z + BALL_RADIUS;
                        ballVelocity.z *= -0.8;
                        ballVelocity.multiplyScalar(0.9);
                        updateMessage("Board!");
                    }
                }

                // 4. Rim Collision (Simplified: Vertical Cylinder)
                const RIM_RADIUS = 0.228;
                const rimCenter = new THREE.Vector2(0, RIM_Z_POS);
                const ballCenterXZ = new THREE.Vector2(ball.position.x, ball.position.z);
                const distanceToRim = ballCenterXZ.distanceTo(rimCenter);
                
                // Only check collision if ball is not yet below rim height
                if (ball.position.y >= RIM_Y_POS - BALL_RADIUS && ball.position.y <= RIM_Y_POS + BALL_RADIUS * 2) {
                    if (distanceToRim < RIM_RADIUS + BALL_RADIUS) {
                        // Collision! Ball can be deflected
                        const normal = ballCenterXZ.clone().sub(rimCenter).normalize();
                        const dot = ballVelocity.x * normal.x + ballVelocity.z * normal.y;
                        
                        // Reflect and dampen
                        ballVelocity.x -= 2 * dot * normal.x * BOUNCE_DAMPING;
                        ballVelocity.z -= 2 * dot * normal.y * BOUNCE_DAMPING;
                        ballVelocity.y *= 0.8; // Vertical bounce reduction
                        
                        // Push out of collision
                        const overlap = RIM_RADIUS + BALL_RADIUS - distanceToRim;
                        ball.position.x += normal.x * overlap;
                        ball.position.z += normal.y * overlap;
                        updateMessage("Clank!");
                    }
                }

                // 5. Score Detection (Pass through the plane of the rim from above)
                if (ball.position.z < RIM_Z_POS + 0.1 && ball.position.z > RIM_Z_POS - 0.1 && !ball.userData.scored) {
                    const rimRadius = 0.228;
                    if (Math.abs(ball.position.x) < rimRadius && ball.position.y < RIM_Y_POS) {
                         // Check for downward trajectory (must be falling)
                        if (ballVelocity.y < 0) {
                            ball.userData.scored = true;
                            
                            // Determine points
                            const isThreePointer = player.position.z > RIM_Z_POS + 6.75;
                            updateScore(isThreePointer ? 3 : 2);
                            
                            setTimeout(resetBall, 2000); // Reset after score
                        }
                    }
                }
            }
        }
        
        function init() {
            // Scene Setup
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x334455);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Game Objects
            createCourt();
            createHoop();
            createPlayer();
            createOpponent();
            createBall();
            
            // Initial Camera Position (Player View)
            camera.position.set(0, 5, 10);
            camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
            
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }
        
        // --- Input Handlers ---
        
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            
            if (key in keysPressed) {
                keysPressed[key] = true;
            }

            // Start Charging Shot
            if (key === 'e' && !isShooting && !isCharging && player.position.y === GROUND_Y) {
                isCharging = true;
                chargeStartTime = performance.now();
                document.getElementById('shot-meter-container').style.display = 'block';
                
                // Determine if it's a layup or jumpshot
                player.userData.isLayup = isInThePaint();
            }
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            
            if (key in keysPressed) {
                keysPressed[key] = false;
            }

            // Fire Shot or Layup
            if (key === 'e' && isCharging) {
                isCharging = false;
                
                const chargeTime = (performance.now() - chargeStartTime) / 1000;
                let power = Math.min(chargeTime / 0.8, MAX_CHARGE_TIME); // Cap power/velocity multiplier

                // Check for 'Green' shot window
                const minGood = MAX_CHARGE_TIME * 0.4;
                const maxGood = MAX_CHARGE_TIME * 0.6;
                const perfectShot = chargeTime >= minGood && chargeTime <= maxGood;

                isGuaranteedShot = perfectShot && !player.userData.isLayup;

                if (perfectShot && !player.userData.isLayup) {
                    updateMessage("PERFECT RELEASE! Swish?");
                } else if (player.userData.isLayup) {
                    // Layup: Jump up, then launch
                    player.userData.verticalVelocity = JUMP_VELOCITY;
                    isJumping = true;
                    setTimeout(launchLayup, 150); // Launch at apex of jump
                    
                } else {
                    // Jumpshot: Jump up, then launch
                    player.userData.verticalVelocity = JUMP_VELOCITY;
                    isJumping = true;
                    updateMessage(chargeTime < minGood ? "Too Early!" : chargeTime > maxGood ? "Too Late!" : "Good Release!");
                    setTimeout(() => launchJumpshot(power), 300); // Launch at apex of jump
                }
                
                document.getElementById('shot-meter-container').style.display = 'none';
                
            } else if (key === 'c') {
                // Toggle Camera View
                currentCameraView = currentCameraView === 'player' ? 'goal' : 'player';
                if (currentCameraView === 'goal') {
                    camera.position.set(0, 4, 15);
                    camera.lookAt(hoop.position);
                    updateMessage("Goal View Activated!");
                } else {
                    updateMessage("Player View Activated!");
                }
            }
        }
        
        // --- Main Game Loop ---

        function animate() {
            requestAnimationFrame(animate);

            updateMovementAndDribble();
            updatePlayerAnimation();
            updateAISimplified();
            updateBallPhysics();
            
            // Shot Meter Update
            if (isCharging) {
                const chargeTime = performance.now() - chargeStartTime;
                let percent = (chargeTime / (MAX_CHARGE_TIME * 1000)) * 100;
                
                // Oscillating meter for better visual
                percent = (Math.abs(Math.sin(chargeTime / 500 * Math.PI))) * 100; 
                
                document.getElementById('shot-bar').style.width = `${percent}%`;
            }
            
            // Goal View Camera (Locked)
            if (currentCameraView === 'goal') {
                camera.lookAt(hoop.position);
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
