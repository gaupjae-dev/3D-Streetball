<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Underground 3D: Neon Nights</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #0f0; 
            background: rgba(0,0,0,0.85); padding: 20px; border: 2px solid #0f0;
            pointer-events: none; z-index: 10; width: 250px;
        }
        #mission-text { color: #ffff00; font-weight: bold; margin-top: 10px; display: none; }
        .hp-bar { width: 100%; height: 10px; background: #300; border: 1px solid #f00; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #f00; transition: 0.3s; }
        #rep-display { color: #00aaff; font-size: 14px; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 20px;">CLANDESTINE BOXING</div>
        <div id="rep-display">Reputation: 0</div>
        <div class="hp-bar"><div id="hp-fill"></div></div>
        <div id="mission-text">MISSION: CLEAR THE DOWNTOWN RING!</div>
        <p style="font-size: 11px; color: #888; margin-top: 15px;">WASD - Move | SPACE - Strike</p>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010103);
        scene.fog = new THREE.Fog(0x010103, 2, 40);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Lighting & Flickering System ---
        const streetLights = [];
        function createStreetLight(x, z) {
            const group = new THREE.Group();
            
            // The Pole
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 2.5;
            group.add(pole);

            // The Bulb Mesh
            const bulbGeo = new THREE.SphereGeometry(0.3);
            const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.y = 5;
            group.add(bulb);

            // The Actual Light
            const light = new THREE.PointLight(0xffaa00, 15, 12);
            light.position.y = 5;
            group.add(light);

            group.position.set(x, 0, z);
            scene.add(group);

            streetLights.push({ light, bulb, originalIntensity: 15 });
        }

        const amb = new THREE.AmbientLight(0x111122, 0.5);
        scene.add(amb);

        // --- Game State ---
        let rep = 0;
        let hp = 100;
        let inMission = false;
        const buildings = [];
        const enemies = [];

        // --- Environment ---
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x080808 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        function makeBuilding(x, z, h, w) {
            const geo = new THREE.BoxGeometry(w, h, w);
            const mat = new THREE.MeshStandardMaterial({ color: 0x050505 });
            const b = new THREE.Mesh(geo, mat);
            b.position.set(x, h/2, z);
            scene.add(b);
            buildings.push(b);
        }

        // Generate City Perimeter and Lights
        for(let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const x = Math.cos(angle) * 18;
            const z = Math.sin(angle) * 18;
            makeBuilding(x, z, 10 + Math.random() * 10, 6);
            if (i % 2 === 0) createStreetLight(Math.cos(angle + 0.3) * 12, Math.sin(angle + 0.3) * 12);
        }

        // Mission Marker
        const marker = new THREE.Mesh(
            new THREE.CylinderGeometry(4, 4, 0.2, 32),
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4 })
        );
        marker.position.y = 0.05;
        scene.add(marker);

        // --- Actors ---
        const player = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 0.8), new THREE.MeshStandardMaterial({color: 0x00aaff}));
        body.position.y = 0.9;
        player.add(body);
        scene.add(player);
        player.position.set(0, 0, 12);

        function spawnEnemy(x, z) {
            const e = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 0.8), new THREE.MeshStandardMaterial({color: 0xff3333}));
            e.position.set(x, 0.9, z);
            e.userData = { hp: 50 };
            scene.add(e);
            enemies.push(e);
        }

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function checkCollision(nextX, nextZ) {
            for (let b of buildings) {
                const bBox = new THREE.Box3().setFromObject(b);
                const pBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextX, 1, nextZ), new THREE.Vector3(1.2, 1.8, 1.2));
                if (bBox.intersectsBox(pBox)) return true;
            }
            return false;
        }

        function update() {
            // Movement
            let moveX = 0, moveZ = 0;
            const speed = 0.15;
            if (keys['w']) moveZ -= speed;
            if (keys['s']) moveZ += speed;
            if (keys['a']) moveX -= speed;
            if (keys['d']) moveX += speed;

            if (!checkCollision(player.position.x + moveX, player.position.z + moveZ)) {
                player.position.x += moveX;
                player.position.z += moveZ;
            }

            // Smooth Camera
            camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 10, player.position.z + 12), 0.05);
            camera.lookAt(player.position);

            // Flickering Logic
            streetLights.forEach(sl => {
                if (Math.random() > 0.96) { // 4% chance to flicker per frame
                    const flicker = Math.random() > 0.5 ? 0 : sl.originalIntensity;
                    sl.light.intensity = flicker;
                    sl.bulb.material.color.setHex(flicker === 0 ? 0x111100 : 0xffaa00);
                }
            });

            // Mission Trigger
            if (player.position.distanceTo(marker.position) < 4 && !inMission) {
                document.getElementById('mission-text').style.display = 'block';
                if (keys[' ']) {
                    inMission = true;
                    spawnEnemy(3, -3); spawnEnemy(-3, -3);
                }
            }

            // Combat
            if (keys[' ']) {
                body.scale.set(1.3, 1, 1.3);
                enemies.forEach((en, i) => {
                    if (player.position.distanceTo(en.position) < 2.5) {
                        en.userData.hp -= 2;
                        en.position.addScaledVector(new THREE.Vector3().subVectors(en.position, player.position).normalize(), 0.3);
                        if (en.userData.hp <= 0) {
                            scene.remove(en);
                            enemies.splice(i, 1);
                            rep += 20;
                            document.getElementById('rep-display').innerText = `Reputation: ${rep}`;
                        }
                    }
                });
            } else { body.scale.set(1, 1, 1); }

            // Enemy AI
            enemies.forEach(en => {
                const dist = en.position.distanceTo(player.position);
                if (dist < 12) {
                    en.position.addScaledVector(new THREE.Vector3().subVectors(player.position, en.position).normalize(), 0.05);
                    if (dist < 1.5) {
                        hp -= 0.3;
                        document.getElementById('hp-fill').style.width = hp + "%";
                    }
                }
            });

            if (hp <= 0) location.reload();
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
